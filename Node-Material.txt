                                           Node.js
..............................................................................................
What is Node.js?
 Node.jsÂ® is a JavaScript runtime built on Chrome's V8 JavaScript engine.
 Node.js is platform for building enterprise Javascript apps.

Why Node.js?
 Ryan Dahl (born 1981) is an American software engineer who is best known for creating the 
Node.js
  Ryan who created node.js for solving the problem of C10K using Javascript language.

C10K:
  The C10k problem is the problem of optimizing network sockets to handle a large number of clients at the same time. 
The name C10k is a numeronym for concurrently handling ten thousand connections.

Blocking and Non Blocking io arch - Sync and async Programming Model
.....................................................................

What is IO? And How io works?

Any thing that is not happening in the cpu called io.

File Descriptor:
................
  Bridge layer between the application and low level 


-FD is a datastructure presented inside os kernal at very low level
-FD is mapper between os and hardware layer
-FD is entry and exit point of os with IO layer
-FD is simple c program.
-FD is broker for io between applications and io os layer

Process:
 File Descriptor is simple c programming, getting loaded into memory once the process inthe
application is started.

Every Process has its own File Descriptor.

Here i have "notepad" - application, when i start notepad , os will create file descriptor in memory.


FD is a table contains information which maps to IO resources

Integer value	Name	<unistd.h> symbolic constant[1]	<stdio.h> file stream[2]
0	Standard input	STDIN_FILENO	stdin
1	Standard output	STDOUT_FILENO	stdout
2	Standard error	STDERR_FILENO	stderr

FD is very simple array.

IO operations and file Descriptors:
....................................

IO opertions can vary from reading data from the keyboard to reading data from disk files and network sockets.

When y read data from the keyboard via FDS it is always done via 0th index of fd.

Use case: 
 I want to read data from the disk file.

if you take any pl, who provides io apis. java.io package and apis 

There are two apis

1.High level api provided by language like java,c,c++..
2.Low level api provided by os - windows,linux,unix,mac....

Flow

Programming language high level api-------> OS low level api------> File Descriptor----|HL
..........................................................................................
.............................................................................................
			Networking and IO : Network IO: Internet
..............................................................................................

Client -Server Architecture :  WebServer Working Model
......................................................

Threading Model:

                         "Request Per Thread Model"


Client-----request(io request)----WebServer--new Thread----Starts handling io operation

100 request = 100 threads

10000 request =10000 threads
.
.............................................................................................

		C10k : concurrently handling ten thousand connections


if create a thread for each request

 =>thread creation,running,control is memory intensive
 =>CPU is always busy with thread ctx switch
.................................................................................
	objective ia how to reduce more threads and keep less threads for io operation.
.............................................................................................
			
Solution:

In 2000, Linux Operating system added new api called "select" Which is first non blocking io api.

select:

1.the first api to make non blocking io calls
2.select works with read method.


poll api :

 poll, ppoll - wait for some event on a file descriptor

In poll we dont need to explicit read call.


epoll api:

epoll is a Linux kernel system call for a scalable I/O event notification mechanism, first introduced in version 2.5. 44 of the Linux kernel. 
Its function is to monitor multiple file descriptors to see whether I/O is possible on any of them.
.............................................................................................
			 C10K was solved by limitting no of io threads
					and 
                         adding event driven io notification facility

Implementations:

1.NGINX server was the first NonBlocking arch
2.Node.js was the second Non Blocking arch

Node.js Architecture
......................
Please refer the diagram
..............................................................................................
				Node.js Programming
..............................................................................................

Node.js is js platform which can run js code.

Js code can be even executed on browser js engine.

Browser JS Engine vs Node.js Engine:
.....................................

Node.js has removed all DOM Api from javascript(browser specific apis)

1.window
   is top/parent api in browser 
node.js does not support window

document,history,location,storage apis........


Browser does not support Node.js specific apis
like all nonblocking io apis, 

1.process 
  like window , process is top level object in node.js

.............................................................................................
				  NODE REPL-(Read Evaulate Print loop)
.............................................................................................

1.Used to run js code interactive manner.


CMD:
node
Welcome to Node.js v16.15.0.
Type ".help" for more information.
>let a =10
undefined
> a
10
> b=20
20
> c = a + b
30
> function sayHello(){
... console.log("Hello")
... }
undefined
> sayHello()
Hello
undefined
> function add(a=10,b=20){
... return a+b
... }
undefined
> add()
30
> add(3,90)
93
..

> document
Uncaught ReferenceError: document is not defined
> location
Uncaught ReferenceError: location is not defined
> process
process {
  version: 'v16.15.0',
  versions: {
    node: '16.15.0',
    v8: '9.4.146.24-node.20',
    uv: '1.43.0',
    zlib: '1.2.11',
    brotli: '1.0.9',
    ares: '1.18.1',
    modules: '93',
    nghttp2: '1.47.0',
    napi: '8',
    llhttp: '6.0.4',
    openssl: '1.1.1n+quic',
    cldr: '40.0',
    icu: '70.1',
    tz: '2021a3',
    unicode: '14.0',
    ngtcp2: '0.1.0-DEV',
    nghttp3: '0.1.0-DEV'
  }
..............................................................................................
				How to write async programming in node
..............................................................................................

Async/nonblocking code:

Classification of async code/nonblocking code

1.NonBlocking IO

 1.1.Network IO
    HTTP,TCP,UDP...

 1.2.File IO
    Reading and writing information from and to disk files
  
 1.3.Process IO
      Transering data in memory(RAM)


2.Timers
   Used to schedule delayed /cpu insentsive tasks using event loop thread


Threading Model and Non blocking apis;
......................................

In General Node is multi threaded.

Node has two types of threads

1.Event Loop Thread /Main Thread

  Event loop thread responsible for running "nonblocking network io apis and timers"
  
  Node supports only one event loop thread(single threaded)

2.Worker threads / worker pool threads
   
  Threads are responsible for running "NonBlocking file io operations"
  Worker pool threads are used for running "Blocking operations - IO,any blocking operations"
   
..............................................................................................
				 Styles of Writing async code in js
..............................................................................................

There are 3 styles

1.callback style
2.Promise Style
3.async await style

Third party style : Reactive Programming- rxjs

1.Using Streams
..............................................................................................

Async implementation using timer api with all style

Timer with callbacks:
......................

1.Callback is a handler function which is registered before sending request to the kernal.
2.Once the task is done by the kernal, which emits events along with data.
3.Event loop thread extracts the events, assigns the handler function(callback) for processing  data.

How to write callbacks?

Every is callback is written based on higher order functions.
//async code with timer -  setTimeout 

// function sayGreet(callback) {
//    callback();
// }
// sayGreet(function () {
//     console.log('Hello')
// })

function saySomething(message) {
    return message
}
// function delay(callback, timeout) {
//     setTimeout(callback, timeout)
// }
const delay = (callback, timeout) => setTimeout(callback, timeout, 'Hello,I am delayed')

console.log(saySomething('start'))
delay(data => console.log(data), 1000)
console.log(saySomething('going on'))

...........................................................................................
				 Callback chaining or callback nesting
..........................................................................................
Sync work flow:
const res1=api1()
const res2=api2(res1)

The sync apis output will be input to another api.

Async work flow:
 The output of one handler , will be input to another handler - callback chaining

Use case

 - call getUser api, which returns user if not , throw error.

 - Based on user i need to call login method, if login failed throw error

 - Based on login output, i need to call dashboard
//callback chaining

const getUser = (user, resolve, reject) => {
    //logic
    if (user) {
        setTimeout(resolve, 1000, user)
    } else {
        setTimeout(reject, 1000, { err: 'User Not Found' })
    }
}

const login = (user, resolve, reject) => {
    if (user.name === 'admin' && user.password === 'admin') {
        setTimeout(resolve, 1000, 'login success')
    } else {
        setTimeout(reject, 1000, 'login failed')
    }
}

const dashboard = (status, resolve, reject) => {
    if (status === 'login success') {
        setTimeout(resolve, 1000, 'Welcome to Admin')
    } else {
        setTimeout(reject, 1000, 'Welcome to Guest')
    }
}

//call api 
let newUser = {
    name: 'admin',
    password: 'admin'
}
// newUser = null
getUser(newUser, user => {
    console.log(user)
    //login
    login(user, status => {
        console.log(status)
        //dashboard
        dashboard(status, adminPage => {
            console.log(adminPage)
        }, guestPage => {
            console.log(guestPage)
        });
    }, err => {
        console.log(err)
    })
}, err => {
    console.log(err)
})


Questions:

1.Whether this code is able to understand quickly
2.Whether this code is able to debug
3.Whehter this code is scalable?
4.whether this code is maintaiable?

No.
                     	 "Callback Hell"
.............................................................................................

fs.readdir(source, function (err, files) {
  if (err) {
    console.log('Error finding files: ' + err)
  } else {
    files.forEach(function (filename, fileIndex) {
      console.log(filename)
      gm(source + filename).size(function (err, values) {
        if (err) {
          console.log('Error identifying file size: ' + err)
        } else {
          console.log(filename + ' : ' + values)
          aspect = (values.width / values.height)
          widths.forEach(function (width, widthIndex) {
            height = Math.round(width / aspect)
            console.log('resizing ' + filename + 'to ' + height + 'x' + height)
            this.resize(width, height).write(dest + 'w' + width + '_' + filename, function(err) {
              if (err) console.log('Error writing file: ' + err)
            })
          }.bind(this))
        }
      })
    })
  }
})

Callback Hell:

 -It is not bug or error in code
 -It is way of writing callback based program
 -Callback based non blocking programming hard to understand,maintain,debug,scale Which 
  called as "Callback Hell".

How to write better async/non blocking code without callbacks?

-Generally without callbacks not possible to write async/non blocking code.
-Rather we can abstract complexity of writting callbacks.


In 2005, JQUERY team started with working complex callback patterns, they found callback hell problem.

They proposed a  Design pattern to write better callback programming(Async) programming.

  "Promise".

Promise is design pattern which hides complexity of callback patterns


Since Promise is design pattern, many people have implemented Promise design pattern.

1.JQuery -first promise implementation
2.many libs and frameworks

...........................................................................................

In order standarize , ECMA committe decided to include Promise Design pattern at language level .(ES 6)
2012 E6 Committe introduced promise design pattern  as  "Promise" Object  in javascript.

Promises and non blocking,async and callback hell issues:
...........................................................................................
				E6 Promise Object
...........................................................................................

ES 6 Promise Object is the reference implementation of "Promise Design Pattern"

Promise Object Creation Patterns
................................

1.Factory pattern
2.Constructor Pattern

Every Promise Object by default is async...Yes Promise Object implements timer with 0 ms by default.


Objective:

 To remove callbacks in async/non blocking code. write cleaner async programming.
 To remove complex callback chaining code.


Promise object methods:
1.then - success
2.catch - errors
3.finally - clean up
factory api to create Promise object
4.resolve
5.reject
.......................................
6.all
7.race

1.Factory pattern
.................

Promise.resolve() =>Promise Object with success and data
Promise.reject()  => Promise Object with failure and error 

//Promise factory api 


function saySomething(message) {
    return message;
}

function delay() {
    return Promise.resolve('Hello,I am promise')
}
//logic with resolve and reject

function auth(userName, password) {
    if (userName === 'admin' && password === 'admin') {
        return Promise.resolve('login success')
    }
    return Promise.reject('Login failed')
}

console.log(saySomething('start'));

delay().then(res => console.log(res))
auth('admin','admin')
    .then(status => console.log(status))
    .catch(err => console.log(err))

console.log(saySomething('going on'));
..........................................................................................
Promise Constructors:
.....................

   "To convert any existing Callback based async implmentations - timers,io"


Promise with Explicit Timers:
//Promise factory api 
function saySomething(message) {
    return message;
}

function delay() {
    //using explicit timer 
    return new Promise((resolve, reject) => {
        //async logic
        setTimeout(resolve, 5000, 'Hello,Promise Constructor')
    })
}
//logic with resolve and reject

function auth(userName, password) {
    return new Promise((resolve, reject) => {
        if (userName === 'admin' && password === 'admin') {
            setTimeout(resolve, 2000, 'login success')
        } else {
            setTimeout(reject, 2000, 'login failed')
        }
    })
}

console.log(saySomething('start'));

delay().then(res => console.log(res))
auth('admin', 'admin')
    .then(status => console.log(status))
    .catch(err => console.log(err))
console.log(saySomething('going on'));
.............................................................................................
				Promise With Callback Hell-Part1
............................................................................................
//callback chaining

const getUser = user => {
    return new Promise((resolve, reject) => {
        if (user) {
            setTimeout(resolve, 1000, user)
        } else {
            setTimeout(reject, 1000, { err: 'User Not Found' })
        }
    })
}

const login = user => {
    return new Promise((resolve, reject) => {
        if (user.name === 'admin' && user.password === 'admin') {
            setTimeout(resolve, 1000, 'login success')
        } else {
            setTimeout(reject, 1000, 'login failed')
        }
    })
}


const dashboard = status => {
    return new Promise((resolve, reject) => {
        if (status === 'login success') {
            setTimeout(resolve, 1000, 'Welcome to Admin')
        } else {
            setTimeout(reject, 1000, 'Welcome to Guest')
        }
    })

}

//call api 
let newUser = {
    name: 'admin',
    password: 'admin'
}
// newUser = null
// getUser(newUser, user => {
//     console.log(user)
//     //login
//     login(user, status => {
//         console.log(status)
//         //dashboard
//         dashboard(status, adminPage => {
//             console.log(adminPage)
//         }, guestPage => {
//             console.log(guestPage)
//         });
//     }, err => {
//         console.log(err)
//     })
// }, err => {
//     console.log(err)
// })

getUser(newUser).then(user => {
    console.log(user)
    login(user).then(status => {
        console.log(status)
        dashboard(status).then(adminPage => console.log(adminPage)).catch(errorPage => {
            console.log(errorPage)
        })
    }).catch(err => {
        console.log(err)
    })
}).catch(err => {
    console.log(err)
});

This caller has many catch blocks, which is even more complex
..............................................................................................
How to refactor the code?

=>Remove multi catch blocks,Keep only one
=>Remove nested Then inside functions -  thenables - chaining then methods

const getUser = user => {
    return new Promise((resolve, reject) => {
        if (user) {
            setTimeout(resolve, 1000, user)
        } else {
            setTimeout(reject, 1000, { err: 'User Not Found' })
        }
    })
}

const login = user => {
    return new Promise((resolve, reject) => {
        if (user.name === 'admin' && user.password === 'admin') {
            setTimeout(resolve, 1000, 'login success')
        } else {
            setTimeout(reject, 1000, 'login failed')
        }
    })
}


const dashboard = status => {
    return new Promise((resolve, reject) => {
        if (status === 'login success') {
            setTimeout(resolve, 1000, 'Welcome to Admin')
        } else {
            setTimeout(reject, 1000, 'Welcome to Guest')
        }
    })

}

//call api 
let newUser = {
    name: 'admin',
    password: 'admin'
}
// getUser(newUser).then(user => {
//     console.log(user)
//     login(user).then(status => {
//         console.log(status)
//         dashboard(status).then(adminPage => console.log(adminPage)).catch(errorPage => {
//             console.log(errorPage)
//         })
//     }).catch(err => {
//         console.log(err)
//     })
// }).catch(err => {
//     console.log(err)
// });

// getUser(newUser)
//     .then(user => {
//         console.log(user)
//         return login(user)
//     })
//     .then(status => {
//         console.log(status)
//         return dashboard(status)
//     }).then(page => {
//         console.log(page)
//     })
//     .catch(err => {
//         console.log(err)
//     })

getUser(newUser)
    .then(user => login(user))
    .then(status => dashboard(status)).then(page => console.log(page))
    .catch(err => console.log(err))
.............................................................................................
				Promise Hell
.............................................................................................

In large code base, you can see many "thenables", how to reduce thenables.

ES 7 introduced even simple keywords , looks like sync program/sequencial call.
"Sync style of async programm"

"async function and await keyword.
..............................................................................................

Async Functions:

=>async functions are declared with async keyword

  async function sayHello(){

  }
=>async functions return Promise with Resolve by default,so async functions are by default non blocking functions


  async function sayHello(){
	return "Hello"  // return Promise.resolve("Hello")

  }
Call with then
  sayHello().then()


function saySomething(message) {
    return message
}

//async functions
async function delay() {
    return "Hello" //Promise.resolve("Hello")
}

console.log(saySomething('start'))
// console.log(delay())
delay().then(res => console.log(res))
console.log(saySomething('going on'))
..............................................................................................
			How to resolve Promises without then and catch
.............................................................................................

await keyword:

=>await keyword is used infront of the function call

   await delay()

=> The function must return Promise,then only await will be valid

=> The await keyword must be used inside async function only.

async function delay() {
    return "Hello" //Promise.resolve("Hello")
}

async function main() {
   const res = await delay()
}


// async function getUser() {
//     return {
//         name: 'admin',
//         password: 'admin'
//     }
// }

function getUser() {
    return Promise.resolve({
        name: 'admin',
        password: 'admin'
    })
}

async function main() {
    try {
        const user = await getUser();
        console.log(user)
    } catch (err) {
        console.log(err)
    }
}
main()
............................................................................................
				 How to reduce thenables in chaining
.............................................................................................
const getUser = user => {
    return new Promise((resolve, reject) => {
        if (user) {
            setTimeout(resolve, 1000, user)
        } else {
            setTimeout(reject, 1000, { err: 'User Not Found' })
        }
    })
}

const login = user => {
    return new Promise((resolve, reject) => {
        if (user.name === 'admin' && user.password === 'admin') {
            setTimeout(resolve, 1000, 'login success')
        } else {
            setTimeout(reject, 1000, 'login failed')
        }
    })
}


const dashboard = status => {
    return new Promise((resolve, reject) => {
        if (status === 'login success') {
            setTimeout(resolve, 1000, 'Welcome to Admin')
        } else {
            setTimeout(reject, 1000, 'Welcome to Guest')
        }
    })

}

//call api 
let newUser = {
    name: 'admin',
    password: 'admin'
}

async function main() {
    // getUser(newUser)
    // .then(user => login(user))
    // .then(status => dashboard(status)).then(page => console.log(page))
    // .catch(err => console.log(err))
     try {
        const user = await getUser(newUser);
        const status = await login(user)
        const page = await dashboard(status)
        console.log(user, status, page)
    }
    catch (err) {
        console.log(err)
    }

}
main();
...........................................................................................
				   Modularity
...........................................................................................
In java Modularity , is presented via "Packages"

Package organize the code  logically.

Customer.java

package com.ibm.cms

public class Customer{}

Java organizes code folders and files Physically.

d:/javaapps/src/
    com/ibm/cms/Customer.java


What about javascript Modularity?

 Javascript is file based modularity physically
 but logically there is no such modularity at language level.

collection of variable declarations and function.

Once js started growing in large scale, dev struck to organize code.

2000, Smart developers started thinking about how to modualrize js code.
 

Module design patterns came.

1.Namespace design pattern : 2000 : jquery
2.AMD -Async Module Defintion : dojo
---------------------------------------------------------
3.CJS - Common JS =  namespace + amd
4.ES 6 Module design pattern  = amd + cjs
------------------------------------------------------------
5.System = AMD = CJS + ES 6
6.UMD = NAMESPACE + AMD + CJS = ES 6


only two design patterns are used in development

1.CJS - Common JS =  namespace + amd
2.ES 6 Module design pattern  = amd + cjs

CJS ; implemented inside node js. node supports commonjs by default.

I can organize the code , based on these patterns, but what about runtimes?
  js runtime never suppport these patterns directly then each design pattern is lib.

 Loaders : it is simple js lib to help link and load js files.

////////////////////////////////////////////////////////////////////////////////////////////
				CommonJS - Implementation
.............................................................................................
CommonJS has three keywords

1.code sharing
-exports
   -used to share code in form of object
   -code is packed inside object and shared that object
-module.exports
   -used to share code as it is.

2.linking files and importing code
require('folder/file')



exports:

src/utils/util.js

//code and pack inside.
//let exports = {message:'Hello'}
exports.message = "Hello"
exports.name = "Subramanian"
//
exports.count = 10
exports.status = true
exports.address = {
    city: 'Coimbatore'
}
exports.skills = ['Java', 'Javascript']
exports.calculate = (a = 0, b = 0) => a * b

src/index.js
const info = require('./uilts/util')

console.log(info)
console.log(info.name,info.message,info.calculate())
........................................................................................

module.exports:
 
=>It does not pack the code inside object, it will return as it is.
=>we cant return mulitple things from module.exports, only one thing you can return
=>It is really suitable for class or single functions /variables sharing.


src/mock-data/todos.js
// const TODOS = [{ id: 1, text: 'learn node', status: true }];

// module.exports = TODOS

module.exports = [{ id: 1, text: 'learn node', status: true }];


src/services/TodoService.js
const TODOS = require('../mock-data/todos')

class TodoService {
    constructor() {
        console.log('TodoService')
    }
    //sync api
    findAll() {
        return TODOS
    }
    //async api - callback based
    findAllAsyncCb(callback) {
        setTimeout(callback, 1000, TODOS)
    }
    //async api - promise based
    findAllAsyncPromise() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000, TODOS)
        })
    }
}

//return class 
// module.exports = TodoService
//return object 
module.exports = new TodoService()

src/index.js
// const TodoService = require('./services/TodoService')
const todoService = require('./services/TodoService')


async function main() {
    // let todoService = new TodoService()
    //sync api call
    console.log(todoService.findAll())
    //async api using callbacks
    todoService.findAllAsyncCb(todos => console.log(todos))
    //async api using Promises
    todoService.findAllAsyncPromise().then(todos => console.log(todos))

    //using async await
    try {
        const todos = await findAllAsyncPromise();
        console.log(todos)
    }
    catch (err) {

    }
}
main()
.............................................................................................
				Types of Modules

1.Custom Modules
   Modules are created by us
2.Node in built modules
   Modules are provided by Node
https://nodejs.org/dist/latest-v16.x/docs/api/

3.Third Party modules.
  Modules are Provied by third parties
eg: all frameworks,libs,utlitites
Angular,React,Vue.............
..............................................................................................
				Node built in modules
..............................................................................................

Operating System Module:
 To get Current Operating System details.

//os
const os = require('os')
console.log(`Arch ${os.arch()}`)
console.log(os.cpus())
..............................................................................................
./ vs ''
.........

 require('./services/TODOService');
  ->here you can see ./
  ./ -current dir

 require('os'); => 
  -here no ./ 

Why?

Note : if you are java devp, you know the classpath , how it works?


require('os');

Node internally uses a search algorthim,node always looks the folder called
 "node_modules" in the current project, if not , then it searches, the node in built 
installtion folder---c:/pf/node/node_modules--if it finds it will pick up from there else it will throw error.

require('./services/TODOService');
   it will lookup in the current dir or sub dirs only.

nternal/modules/cjs/loader.js:800
    throw err;
    ^

Error: Cannot find module 'osxx'
Require stack:
- C:\session\ibm\feb\nodems\mynodeapps\src\index.js
[90m    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:797:15)[39m
[90m    at Function.Module._load (internal/modules/cjs/loader.js:690:27)[39m
[90m    at Module.require (internal/modules/cjs/loader.js:852:19)[39m
[90m    at require (internal/modules/cjs/helpers.js:74:18)[39m
    at Object.<anonymous> (C:\session\ibm\feb\nodems\mynodeapps\src\index.js:1:32)
[90m    at Module._compile (internal/modules/cjs/loader.js:959:30)[39m
[90m    at Object.Module._extensions..js (internal/modules/cjs/loader.js:995:10)[39m
[90m    at Module.load (internal/modules/cjs/loader.js:815:32)[39m
[90m    at Function.Module._load (internal/modules/cjs/loader.js:727:14)[39m
[90m    at Function.Module.runMain (internal/modules/cjs/loader.js:1047:10)[39m {
  code: [32m'MODULE_NOT_FOUND'[39m,
  requireStack: [ [32m'C:\\session\\ibm\\feb\\nodems\\mynodeapps\\src\\index.js'[39m ]
}
//////////////////////////////////////////////////////////////////////////////////////////
				Events Module
...........................................................................................

Node.js is event driven platform.

Types of events:

1.OS events
  The OS kernal's fd emits events, the node process listens for those events.
2.Application events
  The programs can send events to another program.
 One Program is emiter another program is listener.
		
Events module is used to write application events.

Actors:
1.Emiters
2.Listeners


App events can be sync or async

const EventEmitter = require('events')

class ProductService extends EventEmitter {
    constructor() {
        super();
        //register listener 
        this.on('buy', (evt) => {
            console.log(evt)
        })
    }
    //biz method emits events
    buy(product) {
        //emitter
        this.emit('buy', product)
    }
}

function main() {
    let product = new ProductService();
    product.buy({ id: 1, name: 'phone', qty: 3, price: 1000 })
}
main()
..............................................................................................
			      IO Modules
..............................................................................................

File IO:
 Read and write data from and to disk files.

Blocking and NonBlocking File IO:

Node supports nonblocking file io and also blocking file io.

All File IO is carried by "worker pool threads"

NonBlocking File operations are handled by Shared worker pool thread

Blocking File operations are handled by "dedicated Worker Pool thread"

There is module for file io operations -  "fs"

File IO Operation Types:
........................

1.Non Streaming type
2.Streaming Type / evented IO

1.Non Streaming type
//read file using nonstreaming nonblocking api. 

const fs = require('fs')


function saySomething(msg) {
    console.log(msg)
}
const path = "./src/assets/info.txt"
const options = {
    encoding: 'utf-8'
}
saySomething('start')
fs.readFile(path, options, (err, data) => {
    if (err) throw err;
    console.log(data)
})
saySomething('going on')

const fs = require('fs')

function block(message){
    console.log(message)
}

const filePath = './src/assets/info.txt';
const options = {
    encoding: 'UTF-8'
}
block('start')
fs.readFile(filePath, options, (err, data) => {
    if (err) throw err;
    console.log(data)
})
block('end')

////////////////////////////////////////////////////////////////////////////////////////////

Sync : Version of File IO:read
const fs = require('fs')

function block(message) {
    console.log(message)
}

const filePath = './src/assets/info.txt';
const options = {
    encoding: 'UTF-8'
}
block('start')
const data = fs.readFileSync(filePath, options)
console.log(data)
block('end')
//////////////////////////////////////////////////////////////////////////////////////////

How to write data into file async:

const fs = require('fs');

const filePath = './src/assets/infowrite.txt';
const options = {
    encoding: 'utf-8'
}
const data = 'Hello,How are you';

fs.writeFile(filePath, data, options, err => {
  if (err) throw err;
  console.log(`data has been written into ${filePath}`)
})
////////////////////////////////////////////////////////////////////////////////////////////
How to avoid file path hardcoding?

path module:

The path module provides utilities for working with file and directory paths. It can be accessed using:

Node js global variables:

-node provides lot of global variables

__dirname  : current directory name
C:\session\ibm\2021\june\nodemicroservices\nodeapps\src

__filename :current directory name + fileName
C:\session\ibm\2021\june\nodemicroservices\nodeapps\src\index.js

const fs = require('fs');
const path = require('path');

console.log(__dirname)
console.log(__filename)
// const filePath = './src/assets/infowrite.txt';
const filePath = path.join(__dirname,'assets/infowrite.txt')
const options = {
    encoding: 'utf-8'
}
const data = 'Hello,How are you';

fs.writeFile(filePath, data, options, err => {
  if (err) throw err;
  console.log(`data has been written into ${filePath}`)
})
..............................................................................................
				Streaming- File IO -
..............................................................................................

NonStreaming vs Streaming:
.........................

NonStreaming mode loads the entire file into node buffer and delivered to the caller where as streaming mode breaks the file into smaller unit called chunks, each chunk to be streamed to the caller.

Streaming apis are event driven, so that each deliver is considered a emit emission.

1.non streaming:
   only file io is supported, network io not supported

-once file is read, the entire is loaded into node process buffer(memory), then it will be delivered to caller.

-if more files are loaded into node process, node process gets crashed.

-non streaming mode is not suitable for large and big files read or write operation.

fs.readFile() and fs.writeFile are non streaming apis.


2.streaming:
   supported by fs and also network apis


-Streaming is nothing but flow of data(chunks).
-Streaming allows move the data from one place to another place one by one.
-Streaming apis are other wise called evented io. which is powered events.


Types of Streams:

1.Readable Stream : input
2.Writeable stream : output
3.Duplex stream : read + write

Node has lot of built in stream apis
....................................

Built in readable Streams:

-HTTP responses, on the client
-HTTP requests, on the server
-fs read streams
-zlib streams
-crypto streams
-TCP sockets
-child process stdout and stderr
-process.stdin

Writable Streams:

-HTTP requests, on the client
-HTTP responses, on the server
-fs write streams
-zlib streams
-crypto streams
-TCP sockets
-child process stdin
-process.stdout, process.stderr


All streaming apis are powered with events
node io streams has built in events.
events are emitted by node.
Our programs are listeners

Common events in all io

1.data event:
 which is emitted by node, for each chunk.

2.close event:
  The 'close' event is emitted when the stream and any of its underlying resources (a file descriptor, for example) have been closed.

3.end event:
 The 'end' event is emitted when there is no more data to be consumed from the stream.

3.Event: 'error'
 The 'error' event may be emitted by a Readable implementation at any time
Typically, this may occur if the underlying stream is unable to generate data due to an underlying internal failure, or when a stream implementation attempts to push an invalid chunk of data.

const fs = require('fs');
const path = require('path');

const fileName = path.join(__dirname, 'assets/info.txt');

const config = {
    encoding: 'UTF-8'
}
const inputStream = fs.createReadStream(fileName, config);

//register listener in order to listen for data,error..
//data event is emitted by os for each chunk of data
let data = ''
inputStream.on('data', chunk=> {
    console.log(`Received ${chunk.length} bytes of data.`)
    data += chunk;
})

//end event is called , no more chunk of data is availble.
inputStream.on('end', () => {
    console.log('There will be no more data to read!');
    console.log(data);
})

//error event: for error handling
inputStream.on('error', err => {
    console.log(`Some thing went wrong! ${err}`)
});
...........................................................................................
Write Stream:
const fs = require('fs');
const path = require('path');

const fileName = path.join(__dirname, 'assets/grains.txt');

const config = {
    encoding: 'utf8',
    flag: 'w'
};
const outputStream = fs.createWriteStream(fileName, config);

const grains = ['wheat', 'rice', 'oats'];

grains.forEach(grain => {
    outputStream.write(grain + " ");
    console.log("Wrote: %s", grain);
});

outputStream.close();

outputStream.on('close', function () {
    console.log('file has been closed ')
})
............................................................................................
				Chunks Monitoring
............................................................................................


const fs = require('fs');
const path = require('path');
const { log } = console;

const fileName = path.join(__dirname, 'assets/big.file');
const config = {
    encoding: 'UTF-8'
}
const inputStream = fs.createReadStream(fileName, config);

//data event is emitted by os for each chunk of data
let data = ''
inputStream.on('data', chunk=> {
    log(`Received ${chunk.length} bytes of data.`)
    data += chunk;
})

//end event is called , no more chunk of data is availble.
inputStream.on('end', () => {
    log('There will be no more data to read!');
    log(data);
})

//error event: for error handling
inputStream.on('error', err => {
    log(`Some thing went wrong! ${err}`)
});
............................................................................................
				Back Pressure
...........................................................................................

Backpressure:
Problems when you do read and write together

1. In general read operation is faster than write operation


Back Pressure means inputstream is fast, outputstream slow, then data will be
lost.


How to handle back pressure?

 apis  : pause,resume,drain event

pause : to close the upstream, not to emit data
resume : to open the open upstream , to emit data

drain event: if drain event is called.


const fs = require('fs');
const path = require('path');

const inputfileName = path.join(__dirname, 'assets/big.file');
const outputfileName = path.join(__dirname, 'assets/bigcopy.file');

const config = {
    encoding: 'UTF-8'
}

//Back pressure handling
const readerStream = fs.createReadStream(inputfileName, config);
const writeStr = fs.createWriteStream(outputfileName, config);



readerStream.on('data', function (chunk) {
    console.log(`Received ${chunk.length} bytes of data.`);
    let buffer_good = writeStr.write(chunk);
    if (!buffer_good) readerStream.pause();
});
writeStr.on('drain', function () {
    console.log('buffer drained!');
    readerStream.resume();
});
readerStream.on('end', function () {
    //console.log(data);
});

readerStream.on('error', function (err) {
    console.log(err.stack);
});
/////////////////////////////////////////////////////////////////////////////////////////////

pipe method is simplest method for implementing back pressure:


const fs = require('fs');
const path = require('path');

const inputfileName = path.join(__dirname, 'assets/big.file');
//write
const outputFileName = path.join(__dirname, 'assets/bigcopy.file');

const config = {
      encoding: 'UTF-8'
}

//Back pressure handling
const readerStream = fs.createReadStream(inputfileName, config);
const writeStr = fs.createWriteStream(outputFileName, config);

//backPressure streams
//pipe method is simplest method which wraps resume,pasuse,drain 
readerStream.pipe(writeStr);
..............................................................................................
				 Networking 
			     (Networking - HTTP)
.............................................................................................

Node Js Provides HTTP Server,HttpApplication , is nonblocking.

Unlike traditional webservers,node uses single event thread to handle concurrent requests.

Http Module:
The HTTP interfaces in Node.js are designed to support many features of the protocol which have been traditionally difficult to use. In particular, large, possibly chunk-encoded, messages. The interface is careful to never buffer entire requests or responses, so the user is able to stream data.

HTTP modules objects:

1.Server
  Server object is used to implement http servers/web containers
2.ServerResponse
  Object is used to send data 
3.ClientRequest
   Request object is used to handle http client requests
4.IncommingMessage
   Represents message payloads.



Note: all http implemnetation is streaming powered by default.

Steps:

1.create Server.
2.request-response handling
3.starting server

const http = require('http')
//create Server
const server = http.createServer((req, res) => {
    //send response
    res.write('Hello,Http')
    res.end();//terminate current request cycle
})

//Start Server
server.listen(3000,()=>{
    console.log(`Http Server is listening at ${server.address().port} ${server.address().address}`)
})
.............................................................................................
				How to send JSON data
............................................................................................
const http = require('http')

const data = [{
    id: 1,
    name: 'admin'
}, {
    id: 2,
    name: 'guest'
}]


//create Server
const server = http.createServer((req, res) => {
    res.writeHead(200, {
        'Content-Type': 'application/json'
    })
    res.write(JSON.stringify(data))
    res.end();//terminate current request cycle
})

//Start Server
server.listen(3000, () => {
    console.log(`Http Server is listening at ${server.address().port} ${server.address().address}`)
})
..............................................................................................
				How to design layered arch
.............................................................................................


User--------------------->Controller------Service



const data = [{
    id: 1,
    name: 'admin'
}, {
    id: 2,
    name: 'guest'
}]

class UserService {
    constructor() {

    }
    findAll() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 5000, JSON.stringify(data));
        })
    }
}

module.exports = new UserService();

const http = require('http')
const userService = require('./services/user.service')

//create Server
const server = http.createServer(async (req, res) => {
    res.writeHead(200, {
        'Content-Type': 'application/json'
    })
    try {
        const users = await userService.findAll()
        res.end(users);
    }
    catch (err) {
        res.end(err)
    }
})

//Start Server
server.listen(3000, () => {
    console.log(`Http Server is listening at ${server.address().port} ${server.address().address}`)
})
..........................&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&.............................
			How to read input from the Client
.....................................................................................
const http = require('http')
//create Server
const server = http.createServer((req, res) => {
    //read input
    let data = ''
    req.on('data', chunk => {
        data += chunk
    })
    req.on('end', () => {
        console.log(data)
        res.end('Read is completed')
    });
})

//Start Server
server.listen(3000, () => {
    console.log(`Http Server is listening at ${server.address().port} ${server.address().address}`)
})
.........................&&&&&&&&&&&................................................
			    Server events
...................................................................................
const http = require('http')
//create Server
const server = http.createServer((req, res) => {
    res.end('Hello')
})

//Start Server
server.listen(3000, () => {
    console.log(`Http Server is listening at ${server.address().port} ${server.address().address}`)
})
//server events
server.on('request',(req,res)=>{
    console.log(`${req.url} - ${req.method} - ${new Date()}`)
});
....................................................................................
			  NPM - Node Package Manager
...................................................................................

npm is tool is used to distribute node modules to others
and you can get node modules from others.

npm tool is distributed along with node installation

npm uses public repository server called npmjs.com npmjs.org

tools and libs,frameworks all are distributed as node modules into repository.

Javascript Project Structure:(server side/ client side)
.........................................................


The project must have two things

1.package.json file :
   meta file which describes the project information
2.node_modules folder
   which contains libs/frameworks/tools code.


Steps:

1.create project folder
>mkdir nodenpmapp

2.create src folder
 nodenpmapp>mkdir src

3.create package.json file
 npm init
npm init
This utility will walk you through creating a package.json file.
It only covers the most common items, and tries to guess sensible defaults.

See `npm help init` for definitive documentation on these fields
and exactly what they do.

Use `npm install <pkg>` afterwards to install a package and
save it as a dependency in the package.json file.

Press ^C at any time to quit.
package name: (nodenpmapp)
version: (1.0.0)
description: This is npm demo
entry point: (index.js)
test command:
git repository:
keywords: Demo
author: Subramanian Murugan
license: (ISC)
About to write to E:\session\IBM\2022\may\NodewithMS\nodenpmapp\package.json:

{
  "name": "nodenpmapp",
  "version": "1.0.0",
  "description": "This is npm demo",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [
    "Demo"
  ],
  "author": "Subramanian Murugan",
  "license": "ISC"
}


Is this OK? (yes) yes
.....................................................................................
				Package 

Package means collection of node modules(collection of files)
Every software in js is distributed via node packages

Package Types:

1.public package
  react
2.private package 
  @angular - @-npm private 


npm is used

to install,uninstall,publish node modules from node repo / into node repo.

if you install third party modules , into your project, node distributes npm tool ,using this you can install,uninstall,upgrade node modules.


installing module:

>npm install  moduleName  --options
>npm i moduleName --options


>npm install module 
  here no option is told, means default is --save

>npm i module

options:
 --save ; 
 --save-dev
 -g

//////////////////////////////////////////////////////////////////////////////////////////////////////
App development ; three stage

1.dev
2.testing
3.production.

if you install any packages/dependencies, you can tell that is it for production and developemnt, only dev/testing

if you are installing any node module, you can tell, do you want to use only for development
or development + production.

Unit testing libs : Junit.jar===>java

 --save = >    development + production
 --save-dev => only for development

Which code need not be used for production:

1.All testing related  libs/frameworks - unit,e2e
2.Tools like compilers,frameworks related code.

Who will separate out this depedency(lib) for production/dev

  Build tools -  webpack.
  npm itself
    --production
 webpack will scan package.json---extracting prod depedencies


 --save => dev + production
 default =>dev + production

 --save-dev  -->only dev 
.....................................................................................

How to install npm package with dev and production?

npm install lodash --save
npm install jquery  - default to --save (dev and production)

package.json

"dependencies": {
    "jquery": "^3.6.0",
    "lodash": "^4.17.21"
}

How to uninstall/delete/remove npm package?

npm uninstall jquery --save
"dependencies": {
    "lodash": "^4.17.21"
  }

How to install npm package which is used only for dev/test purpose?

npm install pkg --save-dev.

Testing libs:

npm install chai --save-dev

  "devDependencies": {
    "chai": "^4.3.6"
  }
.....................................................................................
	How to install all packages where there is no node_modules folder
.....................................................................................

eg:
 if i am uploading project in github, when i upload , i upload without  "node_modules" folder.

 After cloning how to run the project, if you want to run,you have to install all packages.

npm install 
  It scans package.json file, and installs all packages in one short


what if i want to exclude "dev dependencies", Primearly used for production

npm install --production
   It scans package.json file, and installs only "dependencies" packages in one short
.....................................................................................
				Global Modules
.....................................................................................

-Are installed not inside project, rather installed globally.

 npm install module -g

C:\Users\sasub\AppData\Roaming\npm -- here only all global modules will be installed.


Why Global Modules:

 -Tools
   compilers,webservers,build tools,testing runtime, framework runtime, cli tools for project    creations.

 eg:
  angular cli, react cli(create-react-app) .......

npm install -g @angular/cli

Demo:
....

npm install module-name(tool) -g

mocha : unit testing framwork, is used to run java script unit testing on node and browser.

npm install --global mocha
npm install -g mocha

Steps:

create test folder
 test
create spec file
test
  -demo.spec.js
var assert = require('assert');
describe('Array', function() {
  describe('#indexOf()', function() {
    it('should return -1 when the value is not present', function() {
      assert.equal([1, 2, 3].indexOf(4), -1);
    });
  });
});

nodeapps>mocha

  Array
    #indexOf()
      â should return -1 when the value is not present


  1 passing (8ms)

.....................................................................................
				Scripts
			      (Automation)
.....................................................................................


How to use javascript for automation?


We can automate js applications.

write all auotomation steps inside scripts

 "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  }

key: value

key is called command-script command
value is task to be executed. ; task could be any thing.

command can be built in or custom commands

npm provides lot of built in commands

start,test,postinstall,preinstall..........

How to run node applications?

1.node folderName/filename.js

2.npm start
via script
how to run script

>npm commandname ---incase of built in command
>npm start

>npm run commandname - custom commands
>npm run subu

  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start" : "node src/app.js",
    "subu"  :"node src/app.js"
  },

npm test
npm start
npm run subu
....................................................................................
	        Common Problems in Gobal Modules and how to
			 Solve using  scripts


-Global modules are used for tooling purpose like compilers,build tools,servers,test runners(mocha).

Globals has some issues:

1.version and compablity issue for new projects


Steps:

1.npm uninstall mocha -g

2.>mocha --help
'mocha' is not recognized as an internal or external command,
operable program or batch file.

3.install mocha locally

 npm install mocha --save-dev

4.>mocha
'mocha' is not recognized as an internal or external command,
operable program or batch file.

Why i am getting error?
  because mocha is command, we cant run directly.

5.solution is run via scripts

package.json
"scripts": {
    "test": "mocha",
    "start": "node src/index.js",
    "subu": "node src/index.js"
  }

npm test

> nodeapps@1.0.0 test C:\session\ibm\2021\june\nodemicroservices\nodeapps
> mocha



  Array
    #indexOf()
      â should return -1 when the value is not present


  1 passing (6ms)

/////////////////////////////////////////////////////////////////////////////////////
			  Express.js - Web /Api Framework For node.js
.....................................................................................


What is express?
Express Fast, unopinionated, minimalist web framework for Node.js

express is built on top of http core module.


What apps can be built using express?


1.RESTFull WebServices

2.Dynamic content generation apps -  spring mvc, .netmvc.   with ui


Core features of Express:

1.Abstraction on core http module
2.lot of apis to send data like json api
3.routers : to create HTTP based web services and apps quickly.
4.middlewares : to extend core framework like - logging,database,security,templates...


Express Key concepts: in express every thing object

Objects in express

1.Application
  We call Container object which other objects
  entry and exit of an application
  application is created by calling function

2.Request

3.Response

4.Router


1.Application object roll:

-Routing HTTP requests
-Configuring middleware
-Rendering HTML views
-Registering a template engine

Express Project setup:

1.You can install express dependencies in existing plain node project

2.You can use express cli , to create project structures


Steps:

1.create project folder
2.create src folder
3.npm init
4.install express dependency
5.start writing code

app.js
//express app. 
const express = require('express')

//create application object 
const app = express()

//api 
app.get('/', (req, res) => {
    res.end('Home Page')
})
app.get('/api/users', (req, res) => {
    res.status(200).json([{ id: 1, name: 'admin' }])
})
app.post('/api/users', (req, res) => {
    res.status(200).send('POST')
})
app.put('/api/users', (req, res) => {
    res.status(200).send('PUT')
})
app.delete('/api/users', (req, res) => {
    res.status(200).send('DELETE')
})

//start server

let serverinfo = app.listen(3000, () => {
    console.log(`Express server is running @ ${serverinfo.address().port}`)
})
...................................................................................
			Multi Resources and express

Resource:
 Users
 Products
 Comments
 Customers

//express app. 
const express = require('express')

//create application object 
const app = express()

//api 
app.get('/', (req, res) => {
    res.end('Home Page')
})
app.get('/api/users', (req, res) => {
    res.status(200).json([{ id: 1, name: 'admin' }])
})
app.post('/api/users', (req, res) => {
    res.status(200).send('POST')
})
app.put('/api/users', (req, res) => {
    res.status(200).send('PUT')
})
app.delete('/api/users', (req, res) => {
    res.status(200).send('DELETE')
})

app.get('/api/customers', (req, res) => {
    res.status(200).json([{ id: 1, name: 'admin' }])
})
app.post('/api/customers', (req, res) => {
    res.status(200).send('POST')
})
app.put('/api/customers', (req, res) => {
    res.status(200).send('PUT')
})
app.delete('/api/customers', (req, res) => {
    res.status(200).send('DELETE')
})
//start server

let serverinfo = app.listen(3000, () => {
    console.log(`Express server is running @ ${serverinfo.address().port}`)
})
..................................................................................
			How to scale Express code into modules
..................................................................................

src/routers/user.router.js
//router Object 
const express = require('express')
const userService = require('../services/user.service')
const userRouter = express.Router()

userRouter.get('/list', async (req, res) => {
    try {
        const users = await userService.findAll();
        res.status(200).json(users)
    }
    catch (err) {
        res.status(200).json(err)
    }

})
userRouter.get('/:id', (req, res) => {
    res.send(`user ${req.params.id}`)
})
userRouter.post('/save', (req, res) => {
    res.status(200).send('POST')
})
userRouter.put('/update', (req, res) => {
    res.status(200).send('PUT')
})
userRouter.delete('/remove', (req, res) => {
    res.status(200).send('DELETE')
})

module.exports = userRouter;

src/services/user.service.js

const USERS = [{ id: 1, name: 'admin' }]
class UserService {

    findAll() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000,USERS)
        })
    }
}

module.exports = new UserService();

....
src/app.js
//express app. 
const express = require('express')
const userRouter = require('./routers/users.router')

//create application object 
const app = express()
//binding routers with App 
app.use('/api/users',userRouter)


//global routing/home page 
app.get('/', (req, res) => {
    res.status(200).json({ page: 'HOME PAGE' })
})


//start server

let serverinfo = app.listen(3000, () => {
    console.log(`Express server is running @ ${serverinfo.address().port}`)
})
...................................................................................
			How to read request from the client
...................................................................................


const USERS = [{ id: 1, name: 'admin' }]
class UserService {

    findAll() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000,USERS)
        })
    }
    create(user){
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000,USERS.concat(user))
        })
    }
}

module.exports = new UserService();

//router Object 
const express = require('express')
const userService = require('../services/user.service')
const userRouter = express.Router()

userRouter.get('/list', async (req, res) => {
    try {
        const users = await userService.findAll();
        res.status(200).json(users)
    }
    catch (err) {
        res.status(200).json(err)
    }

})
userRouter.get('/:id', (req, res) => {
    res.send(`user ${req.params.id}`)
})

//
userRouter.post('/save', (req, res) => {
  
    let user = '';
    req.on('data', chunk => {
        user += chunk
    })
    
    req.on('end', async() => {
        try {
            console.log(user)
            const users = await userService.create(user);
            console.log(users)
            res.status(201).location("/api/users/save").json({ message: 'User Created' })
        }
        catch (error) {
            res.status(500).json({ message: error })
        }
    });

})
userRouter.put('/update', (req, res) => {
    res.status(200).send('PUT')
})
userRouter.delete('/remove', (req, res) => {
    res.status(200).send('DELETE')
})

module.exports = userRouter;
.....................................................................................
				Middlewares
.....................................................................................

- plugins , can  be plugged


types of middlewares

1.built in middlewares
2.third party middlewares
3.custom middlewares.



Use case :
 How to read JSON input. Express server need to read json which was submitted by endusers 
User will submit as json --- express need to convert into javascript object.

Without Middleware :

1.we need to register on, end event for reading input
2.we need to convert input into javascript object - JSON.parse()

//
userRouter.post('/save', (req, res) => {
  
    let user = '';
    req.on('data', chunk => {
        user += chunk
    })
    
    req.on('end', async() => {
        try {
            console.log(user)
            const users = await userService.create(JSON.parse(user));
            console.log(users)
            res.status(201).location("/api/users/save").json({ message: 'User Created' })
        }
        catch (error) {
            res.status(500).json({ message: error })
        }
    });

})


With Middleware :

-any middleware is simple javascript module/package only.
-most of the middlewares are community driven.
-if you want any middleware you need to install  

https://expressjs.com/en/resources/middleware.html

body-parser
Node.js body parsing middleware.

Parse incoming request bodies in a middleware before your handlers, available under the req.body property.

Parsers supported by body-parser Middleware:
.............................................

This module provides the following parsers:

1.JSON body parser
2.Raw body parser
3.Text body parser
4.URL-encoded form body parser

Steps:

1.install middleware
$ npm install body-parser

2.Any Middleware must be registered with Application Object.
in order to activate middleware.

app.use(middleware)

//express app. 
const express = require('express')
const bodyParser = require('body-parser')
const userRouter = require('./routers/users.router')

//create application object 
const app = express()

//Register Body parsers
// parse application/json
app.use(bodyParser.json())

//binding routers with App 
app.use('/api/users',userRouter)


//global routing/home page 
app.get('/', (req, res) => {
    res.status(200).json({ page: 'HOME PAGE' })
})


//start server

let serverinfo = app.listen(3000, () => {
    console.log(`Express server is running @ ${serverinfo.address().port}`)
})

//router Object 
const express = require('express')
const userService = require('../services/user.service')
const userRouter = express.Router()

userRouter.get('/list', async (req, res) => {
    try {
        const users = await userService.findAll();
        res.status(200).json(users)
    }
    catch (err) {
        res.status(200).json(err)
    }

})
userRouter.get('/:id', (req, res) => {
    res.send(`user ${req.params.id}`)
})

//with middleware : bodyParser middleware
userRouter.post('/save', async (req, res) => {
    try {
        const user = req.body
        const users = await userService.create(user);
        console.log(users)
        res.status(201).location("/api/users/save").json({ message: 'User Created' })
    }
    catch (error) {
        res.status(500).json({ message: error })
   }

})
userRouter.put('/update', (req, res) => {
    res.status(200).send('PUT')
})
userRouter.delete('/remove', (req, res) => {
    res.status(200).send('DELETE')
})

module.exports = userRouter;
.....................................................................................
				Logger Middleware- morgan
.....................................................................................

npm install morgan

//express app. 
const express = require('express')
const bodyParser = require('body-parser')
const userRouter = require('./routers/users.router')
const morgan = require('morgan')

//create application object 
const app = express()

//Register Body parsers
// parse application/json
app.use(bodyParser.json())
app.use(morgan('tiny'))


//binding routers with App 
app.use('/api/users', userRouter)


//global routing/home page 
app.get('/', (req, res) => {
    res.status(200).json({ page: 'HOME PAGE' })
})


//start server

let serverinfo = app.listen(3000, () => {
    console.log(`Express server is running @ ${serverinfo.address().port}`)
})
...................................................................................
			How to use Express cli project
...................................................................................
npm install -g express-generator

express --view=pug myapp

change directory:
     > cd myapp

   install dependencies:
     > npm install

   run the app:
     > SET DEBUG=myapp:* & npm start

.....................................................................................
			Integration with database-Mongodb
.....................................................................................

db/conn.js

const { MongoClient } = require("mongodb");

const Db = "mongodb://localhost:27017/demo";//process.env.ATLAS_URI;

const client = new MongoClient(Db, {
  useNewUrlParser: true,
  useUnifiedTopology: true,
});

var _db;

module.exports = {
  connectToServer: function (callback) {
    client.connect(function (err, db) {
      // Verify we got a good "db" object
      if (db) {
        _db = db.db("employees");
        console.log("Successfully connected to MongoDB.");
      }
      return callback(err);
    });
  },

  getDb: function () {
    return _db;
  },
};

///
bin/www

#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
const dbo = require("../db/conn");

var debug = require('debug')('myapp:server');
var http = require('http');

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port, () => {
  // perform a database connection when server starts
  dbo.connectToServer(function (err) {
    if (err) console.error(err);

  });
});
server.on('error', onError);
server.on('listening', onListening);

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}

How to send data ?
var express = require('express');
var router = express.Router();
// This will help us connect to the database
const dbo = require("../db/conn");

// This help convert the id from string to ObjectId for the _id.
const ObjectId = require("mongodb").ObjectId;

/* GET users listing. */
router.get('/', function (req, res, next) {
  //data from mongo db
  let db_connect = dbo.getDb("employees");
  db_connect
    .collection("records")
    .find({})
    .toArray(function (err, result) {
      if (err) throw err;
      res.json(result);
    });

});

module.exports = router;








































































































































































