                                           Node.js
..............................................................................................
What is Node.js?
 Node.jsÂ® is a JavaScript runtime built on Chrome's V8 JavaScript engine.
 Node.js is platform for building enterprise Javascript apps.

Why Node.js?
 Ryan Dahl (born 1981) is an American software engineer who is best known for creating the 
Node.js
  Ryan who created node.js for solving the problem of C10K using Javascript language.

C10K:
  The C10k problem is the problem of optimizing network sockets to handle a large number of clients at the same time. 
The name C10k is a numeronym for concurrently handling ten thousand connections.

Blocking and Non Blocking io arch - Sync and async Programming Model
.....................................................................

What is IO? And How io works?

Any thing that is not happening in the cpu called io.

File Descriptor:
................
  Bridge layer between the application and low level 


-FD is a datastructure presented inside os kernal at very low level
-FD is mapper between os and hardware layer
-FD is entry and exit point of os with IO layer
-FD is simple c program.
-FD is broker for io between applications and io os layer

Process:
 File Descriptor is simple c programming, getting loaded into memory once the process inthe
application is started.

Every Process has its own File Descriptor.

Here i have "notepad" - application, when i start notepad , os will create file descriptor in memory.


FD is a table contains information which maps to IO resources

Integer value	Name	<unistd.h> symbolic constant[1]	<stdio.h> file stream[2]
0	Standard input	STDIN_FILENO	stdin
1	Standard output	STDOUT_FILENO	stdout
2	Standard error	STDERR_FILENO	stderr

FD is very simple array.

IO operations and file Descriptors:
....................................

IO opertions can vary from reading data from the keyboard to reading data from disk files and network sockets.

When y read data from the keyboard via FDS it is always done via 0th index of fd.

Use case: 
 I want to read data from the disk file.

if you take any pl, who provides io apis. java.io package and apis 

There are two apis

1.High level api provided by language like java,c,c++..
2.Low level api provided by os - windows,linux,unix,mac....

Flow

Programming language high level api-------> OS low level api------> File Descriptor----|HL
..........................................................................................
.............................................................................................
			Networking and IO : Network IO: Internet
..............................................................................................

Client -Server Architecture :  WebServer Working Model
......................................................

Threading Model:

                         "Request Per Thread Model"


Client-----request(io request)----WebServer--new Thread----Starts handling io operation

100 request = 100 threads

10000 request =10000 threads
.
.............................................................................................

		C10k : concurrently handling ten thousand connections


if create a thread for each request

 =>thread creation,running,control is memory intensive
 =>CPU is always busy with thread ctx switch
.................................................................................
	objective ia how to reduce more threads and keep less threads for io operation.
.............................................................................................
			
Solution:

In 2000, Linux Operating system added new api called "select" Which is first non blocking io api.

select:

1.the first api to make non blocking io calls
2.select works with read method.


poll api :

 poll, ppoll - wait for some event on a file descriptor

In poll we dont need to explicit read call.


epoll api:

epoll is a Linux kernel system call for a scalable I/O event notification mechanism, first introduced in version 2.5. 44 of the Linux kernel. 
Its function is to monitor multiple file descriptors to see whether I/O is possible on any of them.
.............................................................................................
			 C10K was solved by limitting no of io threads
					and 
                         adding event driven io notification facility

Implementations:

1.NGINX server was the first NonBlocking arch
2.Node.js was the second Non Blocking arch

Node.js Architecture
......................
Please refer the diagram
..............................................................................................
				Node.js Programming
..............................................................................................

Node.js is js platform which can run js code.

Js code can be even executed on browser js engine.

Browser JS Engine vs Node.js Engine:
.....................................

Node.js has removed all DOM Api from javascript(browser specific apis)

1.window
   is top/parent api in browser 
node.js does not support window

document,history,location,storage apis........


Browser does not support Node.js specific apis
like all nonblocking io apis, 

1.process 
  like window , process is top level object in node.js

.............................................................................................
				  NODE REPL-(Read Evaulate Print loop)
.............................................................................................

1.Used to run js code interactive manner.


CMD:
node
Welcome to Node.js v16.15.0.
Type ".help" for more information.
>let a =10
undefined
> a
10
> b=20
20
> c = a + b
30
> function sayHello(){
... console.log("Hello")
... }
undefined
> sayHello()
Hello
undefined
> function add(a=10,b=20){
... return a+b
... }
undefined
> add()
30
> add(3,90)
93
..

> document
Uncaught ReferenceError: document is not defined
> location
Uncaught ReferenceError: location is not defined
> process
process {
  version: 'v16.15.0',
  versions: {
    node: '16.15.0',
    v8: '9.4.146.24-node.20',
    uv: '1.43.0',
    zlib: '1.2.11',
    brotli: '1.0.9',
    ares: '1.18.1',
    modules: '93',
    nghttp2: '1.47.0',
    napi: '8',
    llhttp: '6.0.4',
    openssl: '1.1.1n+quic',
    cldr: '40.0',
    icu: '70.1',
    tz: '2021a3',
    unicode: '14.0',
    ngtcp2: '0.1.0-DEV',
    nghttp3: '0.1.0-DEV'
  }
..............................................................................................
				How to write async programming in node
..............................................................................................

Async/nonblocking code:

Classification of async code/nonblocking code

1.NonBlocking IO

 1.1.Network IO
    HTTP,TCP,UDP...

 1.2.File IO
    Reading and writing information from and to disk files
  
 1.3.Process IO
      Transering data in memory(RAM)


2.Timers
   Used to schedule delayed /cpu insentsive tasks using event loop thread


Threading Model and Non blocking apis;
......................................

In General Node is multi threaded.

Node has two types of threads

1.Event Loop Thread /Main Thread

  Event loop thread responsible for running "nonblocking network io apis and timers"
  
  Node supports only one event loop thread(single threaded)

2.Worker threads / worker pool threads
   
  Threads are responsible for running "NonBlocking file io operations"
  Worker pool threads are used for running "Blocking operations - IO,any blocking operations"
   
..............................................................................................
				 Styles of Writing async code in js
..............................................................................................

There are 3 styles

1.callback style
2.Promise Style
3.async await style

Third party style : Reactive Programming- rxjs

1.Using Streams
..............................................................................................

Async implementation using timer api with all style

Timer with callbacks:
......................

1.Callback is a handler function which is registered before sending request to the kernal.
2.Once the task is done by the kernal, which emits events along with data.
3.Event loop thread extracts the events, assigns the handler function(callback) for processing  data.

How to write callbacks?

Every is callback is written based on higher order functions.
//async code with timer -  setTimeout 

// function sayGreet(callback) {
//    callback();
// }
// sayGreet(function () {
//     console.log('Hello')
// })

function saySomething(message) {
    return message
}
// function delay(callback, timeout) {
//     setTimeout(callback, timeout)
// }
const delay = (callback, timeout) => setTimeout(callback, timeout, 'Hello,I am delayed')

console.log(saySomething('start'))
delay(data => console.log(data), 1000)
console.log(saySomething('going on'))

...........................................................................................
				 Callback chaining or callback nesting
..........................................................................................
Sync work flow:
const res1=api1()
const res2=api2(res1)

The sync apis output will be input to another api.

Async work flow:
 The output of one handler , will be input to another handler - callback chaining

Use case

 - call getUser api, which returns user if not , throw error.

 - Based on user i need to call login method, if login failed throw error

 - Based on login output, i need to call dashboard
//callback chaining

const getUser = (user, resolve, reject) => {
    //logic
    if (user) {
        setTimeout(resolve, 1000, user)
    } else {
        setTimeout(reject, 1000, { err: 'User Not Found' })
    }
}

const login = (user, resolve, reject) => {
    if (user.name === 'admin' && user.password === 'admin') {
        setTimeout(resolve, 1000, 'login success')
    } else {
        setTimeout(reject, 1000, 'login failed')
    }
}

const dashboard = (status, resolve, reject) => {
    if (status === 'login success') {
        setTimeout(resolve, 1000, 'Welcome to Admin')
    } else {
        setTimeout(reject, 1000, 'Welcome to Guest')
    }
}

//call api 
let newUser = {
    name: 'admin',
    password: 'admin'
}
// newUser = null
getUser(newUser, user => {
    console.log(user)
    //login
    login(user, status => {
        console.log(status)
        //dashboard
        dashboard(status, adminPage => {
            console.log(adminPage)
        }, guestPage => {
            console.log(guestPage)
        });
    }, err => {
        console.log(err)
    })
}, err => {
    console.log(err)
})


Questions:

1.Whether this code is able to understand quickly
2.Whether this code is able to debug
3.Whehter this code is scalable?
4.whether this code is maintaiable?

No.
                     	 "Callback Hell"
.............................................................................................

fs.readdir(source, function (err, files) {
  if (err) {
    console.log('Error finding files: ' + err)
  } else {
    files.forEach(function (filename, fileIndex) {
      console.log(filename)
      gm(source + filename).size(function (err, values) {
        if (err) {
          console.log('Error identifying file size: ' + err)
        } else {
          console.log(filename + ' : ' + values)
          aspect = (values.width / values.height)
          widths.forEach(function (width, widthIndex) {
            height = Math.round(width / aspect)
            console.log('resizing ' + filename + 'to ' + height + 'x' + height)
            this.resize(width, height).write(dest + 'w' + width + '_' + filename, function(err) {
              if (err) console.log('Error writing file: ' + err)
            })
          }.bind(this))
        }
      })
    })
  }
})

Callback Hell:

 -It is not bug or error in code
 -It is way of writing callback based program
 -Callback based non blocking programming hard to understand,maintain,debug,scale Which 
  called as "Callback Hell".

How to write better async/non blocking code without callbacks?

-Generally without callbacks not possible to write async/non blocking code.
-Rather we can abstract complexity of writting callbacks.


In 2005, JQUERY team started with working complex callback patterns, they found callback hell problem.

They proposed a  Design pattern to write better callback programming(Async) programming.

  "Promise".

Promise is design pattern which hides complexity of callback patterns


Since Promise is design pattern, many people have implemented Promise design pattern.

1.JQuery -first promise implementation
2.many libs and frameworks

...........................................................................................

In order standarize , ECMA committe decided to include Promise Design pattern at language level .(ES 6)
2012 E6 Committe introduced promise design pattern  as  "Promise" Object  in javascript.

Promises and non blocking,async and callback hell issues:
...........................................................................................
				E6 Promise Object
...........................................................................................

ES 6 Promise Object is the reference implementation of "Promise Design Pattern"

Promise Object Creation Patterns
................................

1.Factory pattern
2.Constructor Pattern

Every Promise Object by default is async...Yes Promise Object implements timer with 0 ms by default.


Objective:

 To remove callbacks in async/non blocking code. write cleaner async programming.
 To remove complex callback chaining code.


Promise object methods:
1.then - success
2.catch - errors
3.finally - clean up
factory api to create Promise object
4.resolve
5.reject
.......................................
6.all
7.race

1.Factory pattern
.................

Promise.resolve() =>Promise Object with success and data
Promise.reject()  => Promise Object with failure and error 

//Promise factory api 


function saySomething(message) {
    return message;
}

function delay() {
    return Promise.resolve('Hello,I am promise')
}
//logic with resolve and reject

function auth(userName, password) {
    if (userName === 'admin' && password === 'admin') {
        return Promise.resolve('login success')
    }
    return Promise.reject('Login failed')
}

console.log(saySomething('start'));

delay().then(res => console.log(res))
auth('admin','admin')
    .then(status => console.log(status))
    .catch(err => console.log(err))

console.log(saySomething('going on'));
..........................................................................................
Promise Constructors:
.....................

   "To convert any existing Callback based async implmentations - timers,io"


Promise with Explicit Timers:
//Promise factory api 
function saySomething(message) {
    return message;
}

function delay() {
    //using explicit timer 
    return new Promise((resolve, reject) => {
        //async logic
        setTimeout(resolve, 5000, 'Hello,Promise Constructor')
    })
}
//logic with resolve and reject

function auth(userName, password) {
    return new Promise((resolve, reject) => {
        if (userName === 'admin' && password === 'admin') {
            setTimeout(resolve, 2000, 'login success')
        } else {
            setTimeout(reject, 2000, 'login failed')
        }
    })
}

console.log(saySomething('start'));

delay().then(res => console.log(res))
auth('admin', 'admin')
    .then(status => console.log(status))
    .catch(err => console.log(err))
console.log(saySomething('going on'));
.............................................................................................
				Promise With Callback Hell-Part1
............................................................................................
//callback chaining

const getUser = user => {
    return new Promise((resolve, reject) => {
        if (user) {
            setTimeout(resolve, 1000, user)
        } else {
            setTimeout(reject, 1000, { err: 'User Not Found' })
        }
    })
}

const login = user => {
    return new Promise((resolve, reject) => {
        if (user.name === 'admin' && user.password === 'admin') {
            setTimeout(resolve, 1000, 'login success')
        } else {
            setTimeout(reject, 1000, 'login failed')
        }
    })
}


const dashboard = status => {
    return new Promise((resolve, reject) => {
        if (status === 'login success') {
            setTimeout(resolve, 1000, 'Welcome to Admin')
        } else {
            setTimeout(reject, 1000, 'Welcome to Guest')
        }
    })

}

//call api 
let newUser = {
    name: 'admin',
    password: 'admin'
}
// newUser = null
// getUser(newUser, user => {
//     console.log(user)
//     //login
//     login(user, status => {
//         console.log(status)
//         //dashboard
//         dashboard(status, adminPage => {
//             console.log(adminPage)
//         }, guestPage => {
//             console.log(guestPage)
//         });
//     }, err => {
//         console.log(err)
//     })
// }, err => {
//     console.log(err)
// })

getUser(newUser).then(user => {
    console.log(user)
    login(user).then(status => {
        console.log(status)
        dashboard(status).then(adminPage => console.log(adminPage)).catch(errorPage => {
            console.log(errorPage)
        })
    }).catch(err => {
        console.log(err)
    })
}).catch(err => {
    console.log(err)
});

This caller has many catch blocks, which is even more complex
..............................................................................................
How to refactor the code?

=>Remove multi catch blocks,Keep only one
=>Remove nested Then inside functions -  thenables - chaining then methods

const getUser = user => {
    return new Promise((resolve, reject) => {
        if (user) {
            setTimeout(resolve, 1000, user)
        } else {
            setTimeout(reject, 1000, { err: 'User Not Found' })
        }
    })
}

const login = user => {
    return new Promise((resolve, reject) => {
        if (user.name === 'admin' && user.password === 'admin') {
            setTimeout(resolve, 1000, 'login success')
        } else {
            setTimeout(reject, 1000, 'login failed')
        }
    })
}


const dashboard = status => {
    return new Promise((resolve, reject) => {
        if (status === 'login success') {
            setTimeout(resolve, 1000, 'Welcome to Admin')
        } else {
            setTimeout(reject, 1000, 'Welcome to Guest')
        }
    })

}

//call api 
let newUser = {
    name: 'admin',
    password: 'admin'
}
// getUser(newUser).then(user => {
//     console.log(user)
//     login(user).then(status => {
//         console.log(status)
//         dashboard(status).then(adminPage => console.log(adminPage)).catch(errorPage => {
//             console.log(errorPage)
//         })
//     }).catch(err => {
//         console.log(err)
//     })
// }).catch(err => {
//     console.log(err)
// });

// getUser(newUser)
//     .then(user => {
//         console.log(user)
//         return login(user)
//     })
//     .then(status => {
//         console.log(status)
//         return dashboard(status)
//     }).then(page => {
//         console.log(page)
//     })
//     .catch(err => {
//         console.log(err)
//     })

getUser(newUser)
    .then(user => login(user))
    .then(status => dashboard(status)).then(page => console.log(page))
    .catch(err => console.log(err))
.............................................................................................
				Promise Hell
.............................................................................................

In large code base, you can see many "thenables", how to reduce thenables.

ES 7 introduced even simple keywords , looks like sync program/sequencial call.
"Sync style of async programm"

"async function and await keyword.
..............................................................................................

Async Functions:

=>async functions are declared with async keyword

  async function sayHello(){

  }
=>async functions return Promise with Resolve by default,so async functions are by default non blocking functions


  async function sayHello(){
	return "Hello"  // return Promise.resolve("Hello")

  }
Call with then
  sayHello().then()


function saySomething(message) {
    return message
}

//async functions
async function delay() {
    return "Hello" //Promise.resolve("Hello")
}

console.log(saySomething('start'))
// console.log(delay())
delay().then(res => console.log(res))
console.log(saySomething('going on'))
..............................................................................................
			How to resolve Promises without then and catch
.............................................................................................

await keyword:

=>await keyword is used infront of the function call

   await delay()

=> The function must return Promise,then only await will be valid

=> The await keyword must be used inside async function only.

async function delay() {
    return "Hello" //Promise.resolve("Hello")
}

async function main() {
   const res = await delay()
}


// async function getUser() {
//     return {
//         name: 'admin',
//         password: 'admin'
//     }
// }

function getUser() {
    return Promise.resolve({
        name: 'admin',
        password: 'admin'
    })
}

async function main() {
    try {
        const user = await getUser();
        console.log(user)
    } catch (err) {
        console.log(err)
    }
}
main()
............................................................................................
				 How to reduce thenables in chaining
.............................................................................................
const getUser = user => {
    return new Promise((resolve, reject) => {
        if (user) {
            setTimeout(resolve, 1000, user)
        } else {
            setTimeout(reject, 1000, { err: 'User Not Found' })
        }
    })
}

const login = user => {
    return new Promise((resolve, reject) => {
        if (user.name === 'admin' && user.password === 'admin') {
            setTimeout(resolve, 1000, 'login success')
        } else {
            setTimeout(reject, 1000, 'login failed')
        }
    })
}


const dashboard = status => {
    return new Promise((resolve, reject) => {
        if (status === 'login success') {
            setTimeout(resolve, 1000, 'Welcome to Admin')
        } else {
            setTimeout(reject, 1000, 'Welcome to Guest')
        }
    })

}

//call api 
let newUser = {
    name: 'admin',
    password: 'admin'
}

async function main() {
    // getUser(newUser)
    // .then(user => login(user))
    // .then(status => dashboard(status)).then(page => console.log(page))
    // .catch(err => console.log(err))
     try {
        const user = await getUser(newUser);
        const status = await login(user)
        const page = await dashboard(status)
        console.log(user, status, page)
    }
    catch (err) {
        console.log(err)
    }

}
main();
...........................................................................................
				   Modularity
...........................................................................................
In java Modularity , is presented via "Packages"

Package organize the code  logically.

Customer.java

package com.ibm.cms

public class Customer{}

Java organizes code folders and files Physically.

d:/javaapps/src/
    com/ibm/cms/Customer.java


What about javascript Modularity?

 Javascript is file based modularity physically
 but logically there is no such modularity at language level.

collection of variable declarations and function.

Once js started growing in large scale, dev struck to organize code.

2000, Smart developers started thinking about how to modualrize js code.
 

Module design patterns came.

1.Namespace design pattern : 2000 : jquery
2.AMD -Async Module Defintion : dojo
---------------------------------------------------------
3.CJS - Common JS =  namespace + amd
4.ES 6 Module design pattern  = amd + cjs
------------------------------------------------------------
5.System = AMD = CJS + ES 6
6.UMD = NAMESPACE + AMD + CJS = ES 6


only two design patterns are used in development

1.CJS - Common JS =  namespace + amd
2.ES 6 Module design pattern  = amd + cjs

CJS ; implemented inside node js. node supports commonjs by default.

I can organize the code , based on these patterns, but what about runtimes?
  js runtime never suppport these patterns directly then each design pattern is lib.

 Loaders : it is simple js lib to help link and load js files.

////////////////////////////////////////////////////////////////////////////////////////////
				CommonJS - Implementation
.............................................................................................
CommonJS has three keywords

1.code sharing
-exports
   -used to share code in form of object
   -code is packed inside object and shared that object
-module.exports
   -used to share code as it is.

2.linking files and importing code
require('folder/file')



exports:

src/utils/util.js

//code and pack inside.
//let exports = {message:'Hello'}
exports.message = "Hello"
exports.name = "Subramanian"
//
exports.count = 10
exports.status = true
exports.address = {
    city: 'Coimbatore'
}
exports.skills = ['Java', 'Javascript']
exports.calculate = (a = 0, b = 0) => a * b

src/index.js
const info = require('./uilts/util')

console.log(info)
console.log(info.name,info.message,info.calculate())
........................................................................................

module.exports:
 
=>It does not pack the code inside object, it will return as it is.
=>we cant return mulitple things from module.exports, only one thing you can return
=>It is really suitable for class or single functions /variables sharing.


src/mock-data/todos.js
// const TODOS = [{ id: 1, text: 'learn node', status: true }];

// module.exports = TODOS

module.exports = [{ id: 1, text: 'learn node', status: true }];


src/services/TodoService.js
const TODOS = require('../mock-data/todos')

class TodoService {
    constructor() {
        console.log('TodoService')
    }
    //sync api
    findAll() {
        return TODOS
    }
    //async api - callback based
    findAllAsyncCb(callback) {
        setTimeout(callback, 1000, TODOS)
    }
    //async api - promise based
    findAllAsyncPromise() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000, TODOS)
        })
    }
}

//return class 
// module.exports = TodoService
//return object 
module.exports = new TodoService()

src/index.js
// const TodoService = require('./services/TodoService')
const todoService = require('./services/TodoService')


async function main() {
    // let todoService = new TodoService()
    //sync api call
    console.log(todoService.findAll())
    //async api using callbacks
    todoService.findAllAsyncCb(todos => console.log(todos))
    //async api using Promises
    todoService.findAllAsyncPromise().then(todos => console.log(todos))

    //using async await
    try {
        const todos = await findAllAsyncPromise();
        console.log(todos)
    }
    catch (err) {

    }
}
main()
.............................................................................................
				Types of Modules

1.Custom Modules
   Modules are created by us
2.Node in built modules
   Modules are provided by Node
https://nodejs.org/dist/latest-v16.x/docs/api/

3.Third Party modules.
  Modules are Provied by third parties
eg: all frameworks,libs,utlitites
Angular,React,Vue.............
..............................................................................................
				Node built in modules
..............................................................................................

Operating System Module:
 To get Current Operating System details.

//os
const os = require('os')
console.log(`Arch ${os.arch()}`)
console.log(os.cpus())
..............................................................................................
./ vs ''
.........

 require('./services/TODOService');
  ->here you can see ./
  ./ -current dir

 require('os'); => 
  -here no ./ 

Why?

Note : if you are java devp, you know the classpath , how it works?


require('os');

Node internally uses a search algorthim,node always looks the folder called
 "node_modules" in the current project, if not , then it searches, the node in built 
installtion folder---c:/pf/node/node_modules--if it finds it will pick up from there else it will throw error.

require('./services/TODOService');
   it will lookup in the current dir or sub dirs only.

nternal/modules/cjs/loader.js:800
    throw err;
    ^

Error: Cannot find module 'osxx'
Require stack:
- C:\session\ibm\feb\nodems\mynodeapps\src\index.js
[90m    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:797:15)[39m
[90m    at Function.Module._load (internal/modules/cjs/loader.js:690:27)[39m
[90m    at Module.require (internal/modules/cjs/loader.js:852:19)[39m
[90m    at require (internal/modules/cjs/helpers.js:74:18)[39m
    at Object.<anonymous> (C:\session\ibm\feb\nodems\mynodeapps\src\index.js:1:32)
[90m    at Module._compile (internal/modules/cjs/loader.js:959:30)[39m
[90m    at Object.Module._extensions..js (internal/modules/cjs/loader.js:995:10)[39m
[90m    at Module.load (internal/modules/cjs/loader.js:815:32)[39m
[90m    at Function.Module._load (internal/modules/cjs/loader.js:727:14)[39m
[90m    at Function.Module.runMain (internal/modules/cjs/loader.js:1047:10)[39m {
  code: [32m'MODULE_NOT_FOUND'[39m,
  requireStack: [ [32m'C:\\session\\ibm\\feb\\nodems\\mynodeapps\\src\\index.js'[39m ]
}
//////////////////////////////////////////////////////////////////////////////////////////
				Events Module
...........................................................................................

Node.js is event driven platform.

Types of events:

1.OS events
  The OS kernal's fd emits events, the node process listens for those events.
2.Application events
  The programs can send events to another program.
 One Program is emiter another program is listener.
		
Events module is used to write application events.

Actors:
1.Emiters
2.Listeners


App events can be sync or async

const EventEmitter = require('events')

class ProductService extends EventEmitter {
    constructor() {
        super();
        //register listener 
        this.on('buy', (evt) => {
            console.log(evt)
        })
    }
    //biz method emits events
    buy(product) {
        //emitter
        this.emit('buy', product)
    }
}

function main() {
    let product = new ProductService();
    product.buy({ id: 1, name: 'phone', qty: 3, price: 1000 })
}
main()
..............................................................................................
			      IO Modules
..............................................................................................

File IO:
 Read and write data from and to disk files.

Blocking and NonBlocking File IO:

Node supports nonblocking file io and also blocking file io.

All File IO is carried by "worker pool threads"

NonBlocking File operations are handled by Shared worker pool thread

Blocking File operations are handled by "dedicated Worker Pool thread"

There is module for file io operations -  "fs"

File IO Operation Types:
........................

1.Non Streaming type
2.Streaming Type / evented IO

1.Non Streaming type
//read file using nonstreaming nonblocking api. 

const fs = require('fs')


function saySomething(msg) {
    console.log(msg)
}
const path = "./src/assets/info.txt"
const options = {
    encoding: 'utf-8'
}
saySomething('start')
fs.readFile(path, options, (err, data) => {
    if (err) throw err;
    console.log(data)
})
saySomething('going on')

const fs = require('fs')

function block(message){
    console.log(message)
}

const filePath = './src/assets/info.txt';
const options = {
    encoding: 'UTF-8'
}
block('start')
fs.readFile(filePath, options, (err, data) => {
    if (err) throw err;
    console.log(data)
})
block('end')

////////////////////////////////////////////////////////////////////////////////////////////

Sync : Version of File IO:read
const fs = require('fs')

function block(message) {
    console.log(message)
}

const filePath = './src/assets/info.txt';
const options = {
    encoding: 'UTF-8'
}
block('start')
const data = fs.readFileSync(filePath, options)
console.log(data)
block('end')
//////////////////////////////////////////////////////////////////////////////////////////

How to write data into file async:

const fs = require('fs');

const filePath = './src/assets/infowrite.txt';
const options = {
    encoding: 'utf-8'
}
const data = 'Hello,How are you';

fs.writeFile(filePath, data, options, err => {
  if (err) throw err;
  console.log(`data has been written into ${filePath}`)
})
////////////////////////////////////////////////////////////////////////////////////////////
How to avoid file path hardcoding?

path module:

The path module provides utilities for working with file and directory paths. It can be accessed using:

Node js global variables:

-node provides lot of global variables

__dirname  : current directory name
C:\session\ibm\2021\june\nodemicroservices\nodeapps\src

__filename :current directory name + fileName
C:\session\ibm\2021\june\nodemicroservices\nodeapps\src\index.js

const fs = require('fs');
const path = require('path');

console.log(__dirname)
console.log(__filename)
// const filePath = './src/assets/infowrite.txt';
const filePath = path.join(__dirname,'assets/infowrite.txt')
const options = {
    encoding: 'utf-8'
}
const data = 'Hello,How are you';

fs.writeFile(filePath, data, options, err => {
  if (err) throw err;
  console.log(`data has been written into ${filePath}`)
})
..............................................................................................
				Streaming- File IO -
..............................................................................................

NonStreaming vs Streaming:
.........................

NonStreaming mode loads the entire file into node buffer and delivered to the caller where as streaming mode breaks the file into smaller unit called chunks, each chunk to be streamed to the caller.

Streaming apis are event driven, so that each deliver is considered a emit emission.

1.non streaming:
   only file io is supported, network io not supported

-once file is read, the entire is loaded into node process buffer(memory), then it will be delivered to caller.

-if more files are loaded into node process, node process gets crashed.

-non streaming mode is not suitable for large and big files read or write operation.

fs.readFile() and fs.writeFile are non streaming apis.


2.streaming:
   supported by fs and also network apis


-Streaming is nothing but flow of data(chunks).
-Streaming allows move the data from one place to another place one by one.
-Streaming apis are other wise called evented io. which is powered events.


Types of Streams:

1.Readable Stream : input
2.Writeable stream : output
3.Duplex stream : read + write

Node has lot of built in stream apis
....................................

Built in readable Streams:

-HTTP responses, on the client
-HTTP requests, on the server
-fs read streams
-zlib streams
-crypto streams
-TCP sockets
-child process stdout and stderr
-process.stdin

Writable Streams:

-HTTP requests, on the client
-HTTP responses, on the server
-fs write streams
-zlib streams
-crypto streams
-TCP sockets
-child process stdin
-process.stdout, process.stderr


All streaming apis are powered with events
node io streams has built in events.
events are emitted by node.
Our programs are listeners

Common events in all io

1.data event:
 which is emitted by node, for each chunk.

2.close event:
  The 'close' event is emitted when the stream and any of its underlying resources (a file descriptor, for example) have been closed.

3.end event:
 The 'end' event is emitted when there is no more data to be consumed from the stream.

3.Event: 'error'
 The 'error' event may be emitted by a Readable implementation at any time
Typically, this may occur if the underlying stream is unable to generate data due to an underlying internal failure, or when a stream implementation attempts to push an invalid chunk of data.

const fs = require('fs');
const path = require('path');

const fileName = path.join(__dirname, 'assets/info.txt');

const config = {
    encoding: 'UTF-8'
}
const inputStream = fs.createReadStream(fileName, config);

//register listener in order to listen for data,error..
//data event is emitted by os for each chunk of data
let data = ''
inputStream.on('data', chunk=> {
    console.log(`Received ${chunk.length} bytes of data.`)
    data += chunk;
})

//end event is called , no more chunk of data is availble.
inputStream.on('end', () => {
    console.log('There will be no more data to read!');
    console.log(data);
})

//error event: for error handling
inputStream.on('error', err => {
    console.log(`Some thing went wrong! ${err}`)
});
...........................................................................................
Write Stream:
const fs = require('fs');
const path = require('path');

const fileName = path.join(__dirname, 'assets/grains.txt');

const config = {
    encoding: 'utf8',
    flag: 'w'
};
const outputStream = fs.createWriteStream(fileName, config);

const grains = ['wheat', 'rice', 'oats'];

grains.forEach(grain => {
    outputStream.write(grain + " ");
    console.log("Wrote: %s", grain);
});

outputStream.close();

outputStream.on('close', function () {
    console.log('file has been closed ')
})
............................................................................................
				Chunks Monitoring
............................................................................................


const fs = require('fs');
const path = require('path');
const { log } = console;

const fileName = path.join(__dirname, 'assets/big.file');
const config = {
    encoding: 'UTF-8'
}
const inputStream = fs.createReadStream(fileName, config);

//data event is emitted by os for each chunk of data
let data = ''
inputStream.on('data', chunk=> {
    log(`Received ${chunk.length} bytes of data.`)
    data += chunk;
})

//end event is called , no more chunk of data is availble.
inputStream.on('end', () => {
    log('There will be no more data to read!');
    log(data);
})

//error event: for error handling
inputStream.on('error', err => {
    log(`Some thing went wrong! ${err}`)
});
............................................................................................
				Back Pressure
...........................................................................................

Backpressure:
Problems when you do read and write together

1. In general read operation is faster than write operation


Back Pressure means inputstream is fast, outputstream slow, then data will be
lost.


How to handle back pressure?

 apis  : pause,resume,drain event

pause : to close the upstream, not to emit data
resume : to open the open upstream , to emit data

drain event: if drain event is called.


const fs = require('fs');
const path = require('path');

const inputfileName = path.join(__dirname, 'assets/big.file');
const outputfileName = path.join(__dirname, 'assets/bigcopy.file');

const config = {
    encoding: 'UTF-8'
}

//Back pressure handling
const readerStream = fs.createReadStream(inputfileName, config);
const writeStr = fs.createWriteStream(outputfileName, config);



readerStream.on('data', function (chunk) {
    console.log(`Received ${chunk.length} bytes of data.`);
    let buffer_good = writeStr.write(chunk);
    if (!buffer_good) readerStream.pause();
});
writeStr.on('drain', function () {
    console.log('buffer drained!');
    readerStream.resume();
});
readerStream.on('end', function () {
    //console.log(data);
});

readerStream.on('error', function (err) {
    console.log(err.stack);
});
/////////////////////////////////////////////////////////////////////////////////////////////

pipe method is simplest method for implementing back pressure:


const fs = require('fs');
const path = require('path');

const inputfileName = path.join(__dirname, 'assets/big.file');
//write
const outputFileName = path.join(__dirname, 'assets/bigcopy.file');

const config = {
      encoding: 'UTF-8'
}

//Back pressure handling
const readerStream = fs.createReadStream(inputfileName, config);
const writeStr = fs.createWriteStream(outputFileName, config);

//backPressure streams
//pipe method is simplest method which wraps resume,pasuse,drain 
readerStream.pipe(writeStr);
..............................................................................................
				Networking 
			     (Networking - HTTP)
.............................................................................................

Node Js Provides HTTP Server,HttpApplication , is nonblocking.

Unlike traditional webservers,node uses single event thread to handle concurrent requests.

Http Module:
The HTTP interfaces in Node.js are designed to support many features of the protocol which have been traditionally difficult to use. In particular, large, possibly chunk-encoded, messages. The interface is careful to never buffer entire requests or responses, so the user is able to stream data.

HTTP modules objects:

1.Server
  Server object is used to implement http servers/web containers
2.ServerResponse
  Object is used to send data 
3.ClientRequest
   Request object is used to handle http client requests
4.IncommingMessage
   Represents message payloads.



Note: all http implemnetation is streaming powered by default.

Steps:

1.create Server.
2.request-response handling
3.starting server

const http = require('http')
//create Server
const server = http.createServer((req, res) => {
    //send response
    res.write('Hello,Http')
    res.end();//terminate current request cycle
})

//Start Server
server.listen(3000,()=>{
    console.log(`Http Server is listening at ${server.address().port} ${server.address().address}`)
})
.............................................................................................
				How to send JSON data
............................................................................................
const http = require('http')

const data = [{
    id: 1,
    name: 'admin'
}, {
    id: 2,
    name: 'guest'
}]


//create Server
const server = http.createServer((req, res) => {
    res.writeHead(200, {
        'Content-Type': 'application/json'
    })
    res.write(JSON.stringify(data))
    res.end();//terminate current request cycle
})

//Start Server
server.listen(3000, () => {
    console.log(`Http Server is listening at ${server.address().port} ${server.address().address}`)
})
..............................................................................................
				How to design layered arch
.............................................................................................


User--------------------->Controller------Service



const data = [{
    id: 1,
    name: 'admin'
}, {
    id: 2,
    name: 'guest'
}]

class UserService {
    constructor() {

    }
    findAll() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 5000, JSON.stringify(data));
        })
    }
}

module.exports = new UserService();

const http = require('http')
const userService = require('./services/user.service')

//create Server
const server = http.createServer(async (req, res) => {
    res.writeHead(200, {
        'Content-Type': 'application/json'
    })
    try {
        const users = await userService.findAll()
        res.end(users);
    }
    catch (err) {
        res.end(err)
    }
})

//Start Server
server.listen(3000, () => {
    console.log(`Http Server is listening at ${server.address().port} ${server.address().address}`)
})
..........................&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&....................................















































































































































