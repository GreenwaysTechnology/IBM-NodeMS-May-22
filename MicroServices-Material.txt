                  		Micro services 
			        Implementations 
				    on 
				 Node.js
.....................................................................................

What is MicroService?
 It describes a particular way of designing software applications as suites of independently deployable services

It is an architectural style that structures an application as a collection of services that are

Highly maintainable and testable
=>Loosely coupled
=>Independently deployable
=>Organized around business capabilities
=>Owned by a small team

What is Monolothic ?
 It describes a particular way of designing software applications, deployed as single 
unit

How to start building distributed apps based Microservice Arch?

You have to follow the pattern language : Collection of design patterns


Patterns:

Patterns can be classified into two category

System Design
  ->Microservice 
  ->Monolithic

1.1.Decomposition
    How to an analysis the problem domain
 Decompose by business capability
 Decompose by subdomain
 Self-contained Servicenew
 Service per teamnew

2.Program implemetation

Data management
1.Database per Service
2.Shared database
3.Saga
4.API Composition
5.CQRS
6.Domain event
7.Event sourcing

Coding:

API Design - Service Representation
  =>REST API
  =>SOAP API
  =>GraphQL API
  =>RPC / RPI

API Communication style
=>Remote Procedure Invocation
=>Messaging
=>Domain-specific protocol
=>Idempotent Consumer


API Communication - Reliability
=>Circuit Breaker
=>Timeout
=>Fallback
=>BulkHead
=>Retry

API Communication -Service Discovery

   Api communication should happen via centeralized broker

=>Client-side discovery
=>Server-side discovery
=>Service registry
=>Self registration
=>3rd party registration

Cross cutting concerns
=>Microservice chassis
=>Service Template
=>Externalized configuration


Security
=>Access Token

Testing

=>Service Component Test
=>Consumer-driven contract test
=>Consumer-side contract test
........................................................................

Production Stage:

Deployment patterns

=>Multiple service instances per host
=>Service instance per host
=>Service instance per VM
=>Service instance per Container
=>Serverless deployment
=>Service deployment platform

Monitoring Apps in Production-Observability
=>Log aggregation
=>Application metrics
=>Audit logging
=>Distributed tracing
=>Exception tracking
=>Health check API
=>Log deployments and changes
....................................................................................
				Microservice Arch Phases

1.System Design
2.Development
3.Testing
4.Deployment
5.Maintaince and Monitoring
....................................................................................
			 Micro service Implementations


Microservices are just concepts, we can implement in any language, any framework,libs

Java script implementations(Node.js Implementations).

1.Moleculer
2.Nest
3.IBM Strong loop and loopback
.....................................................................................
				Moleculer
....................................................................................

Progressive microservices framework for Node.js

Moleculer is framework which has implemented most of common microservices design patterns.

Moleculer features:

1.Promise-based solution (async/await compatible)
2.request-reply concept
3.support event driven architecture with balancing
4.built-in service registry & dynamic service discovery
5.load balanced requests & events (round-robin, random, cpu-usage, latency, sharding)
6.many fault tolerance features (Circuit Breaker, Bulkhead, Retry, Timeout, Fallback)
7.plugin/middleware system
8.support versioned services
9.support Streams
10.service mixins
11.built-in caching solution (Memory, MemoryLRU, Redis)
12.pluggable loggers (Console, File, Pino, Bunyan, Winston, Debug, Datadog, Log4js)
13.pluggable transporters (TCP, NATS, MQTT, Redis, NATS Streaming, Kafka, AMQP 0.9, AMQP 1.0)
14.pluggable serializers (JSON, Avro, MsgPack, Protocol Buffer, Thrift)
15.pluggable parameter validator
16.multiple services on a node/server
17.master-less architecture, all nodes are equal
18.parameter validation with fastest-validator
19.built-in metrics feature with reporters (Console, CSV, Datadog, Event, Prometheus, StatsD)
20.built-in tracing feature with exporters (Console, Datadog, Event, Jaeger, Zipkin)
21.official API gateway, Database access and many other modules…
.....................................................................................

Moleculer setup:

project creations;

1.from begining like normal node application.
2.moleculer cli- to setup realtime project with all artifacts.


1.Service
 A service is a simple JavaScript module containing some part of a complex application. 
 A service represents a biz logic in your application.

2.Service Broker : == Spring Container

 Service Broker is the heart of Moleculer.

It is responsible for management and communication between services (local and remote). 

3.node :
 A node is a simple OS process running on a local or external network.
 A single instance of a node can host one or many services.
 node js platform - v8+libvu..

Each node must have an instance of Service Broker.

"Service Broker is one single Node instance - Node runtime"

4.Transporter
	Transporter is a communication bus that services use to exchange messages. 
 It transfers events, requests and responses.

5.Gateway
     API Gateway exposes Moleculer services to end-users.
 The gateway is a regular Moleculer service running a (HTTP, WebSockets, etc.) server. It handles the incoming requests, maps them into service calls, and then returns appropriate responses.
.....................................................................................

Services:

1.Back end services- rpc
   Services are used to encasulate biz logics like database operations,any biz

2.HTTP services
   Services are exposed for outsideworld


service names and file names:

math.service.js
hello.service.js

Use case 1: how to create ServiceBroker object

const { ServiceBroker } = require("moleculer")

//create broker object
const broker = new ServiceBroker();

node services/hello.service.js
[2022-05-25T10:26:15.256Z] INFO  laptop-r2tggfdl-18360/BROKER: Moleculer v0.14.21 is starting...
[2022-05-25T10:26:15.259Z] INFO  laptop-r2tggfdl-18360/BROKER: Namespace: <not defined>
[2022-05-25T10:26:15.259Z] INFO  laptop-r2tggfdl-18360/BROKER: Node ID: laptop-r2tggfdl-18360
[2022-05-25T10:26:15.263Z] INFO  laptop-r2tggfdl-18360/REGISTRY: Strategy: RoundRobinStrategy
[2022-05-25T10:26:15.264Z] INFO  laptop-r2tggfdl-18360/REGISTRY: Discoverer: LocalDiscoverer
[2022-05-25T10:26:15.281Z] INFO  laptop-r2tggfdl-18360/BROKER: Serializer: JSONSerializer
[2022-05-25T10:26:15.297Z] INFO  laptop-r2tggfdl-18360/BROKER: Validator: FastestValidator
[2022-05-25T10:26:15.302Z] INFO  laptop-r2tggfdl-18360/BROKER: Registered 13 middleware(s).
[2022-05-25T10:26:15.316Z] INFO  laptop-r2tggfdl-18360/$NODE: Service '$node' stopped.
[2022-05-25T10:26:15.316Z] INFO  laptop-r2tggfdl-18360/BROKER: ServiceBroker is stopped. Good bye.
...............................................................................
				How to start ServiceBroker
..................................................................................
const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker()



//start the container
function main() {
    broker.start().then(() => {
        console.log('Service Broker is Ready!')
    }).catch(err => console.log(err))
}
main()
....................................................................................
			How to write simple service

const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker()

//service definition
broker.createService({
    name: 'hello',
    actions: {
        //apis 
        sayHello() {
            return 'Hello'
        }
    }
})

//start the container
// function main() {
//     broker.start().then(() => {
//         console.log('Service Broker is Ready!')
//         //call service
//         broker.call('hello.sayHello').then(res => {
//             console.log(res)
//         }).catch(err => {
//             console.log(err)
//         })

//     }).catch(err => console.log(err))
// }
async function main() {
    try {
        await broker.start()
        const res = await broker.call('hello.sayHello')
        console.log(res)
    }
    catch (err) {
        console.log(err)
    }
}
main()
....................................................................................
				Multi Api Service
...................................................................................
const { ServiceBroker } = require('moleculer')
const broker = new ServiceBroker()

broker.createService({
    name: 'greeter',
    actions: {
        //apis 
        sayHello() {
            return 'Hello'
        },
        sayHai() {
            return 'Hai'
        },
        sayGreet() {
            return 'Greet'
        }

    }
})

async function main() {
    try {
        await broker.start()
        const hello = await broker.call('greeter.sayHello')
        const hi = await broker.call('greeter.sayHai')
        const greet = await broker.call('greeter.sayGreet')
        console.log(`${hello} ${hi} ${greet}`)
    }
    catch (err) {
        console.log(err)
    }
}
main()

...................................................................................
				Multiple services

....................................................................................
const { ServiceBroker } = require('moleculer')
const broker = new ServiceBroker()

//hello Service
broker.createService({
    name: 'hello',
    actions: {
        sayHello() {
            return 'Hello'
        }
    }
})
broker.createService({
    name: 'hai',
    actions: {
        sayHai() {
            return 'Hai'
        }
    }
})

broker.createService({
    name: 'greeter',
    actions: {
        sayGreet() {
            return 'Greet'
        }

    }
})
async function main() {
    try {
        await broker.start()
        const hello = await broker.call('hello.sayHello')
        const hi = await broker.call('hai.sayHai')
        const greet = await broker.call('greeter.sayGreet')
        console.log(`${hello} ${hi} ${greet}`)

    }
    catch (err) {
        console.log(err)
    }
}
main()
....................................................................................
			  Service Versioning
..................................................................................

const { ServiceBroker } = require("moleculer")

const broker = new ServiceBroker();

broker.createService({
    name: 'hello',
    version: 1,
    actions: {
        sayHello() {
            return `Hello V1`
        }
    }
})
broker.createService({
    name: 'hello',
    version: 2,
    actions: {
        sayHello() {
            return `Hello V2`
        }
    }
})

async function main() {

    try {
        await broker.start()
        console.log('Service Broker is ready')
        //invoke service api
        //versionNo.serviceName.serviceMethod
        const helloV1 = await broker.call('v1.hello.sayHello');
        const helloV2 = await broker.call('v2.hello.sayHello');
        console.log(helloV1,helloV2)

    } catch (error) {
        console.log(error)
    }
}
main();
....................................................................................
				Actions Types
...................................................................................
actions:
  Are used to represent methods.

Methods can be represented in two ways:

Way -1:
actions : {
 
  sayHello(){
     return 'hello'
  }

}
Way-2: you can add meta information to a method

meta informations will discuss later.

actions: {
  
  sayHello: {
    
       handler(){
          
          return 'Hello'
           
       } 
  }

} 
const { ServiceBroker } = require('moleculer')
const broker = new ServiceBroker()

broker.createService({
    name: 'greeter',
    actions: {
        //way 1
        sayHello() {
            return 'Hello'
        },
        //way -2
        sayHai: {
            handler() {
                return 'Hai'
            }
        }
    }
})

async function main() {
    try {
        await broker.start()
        const hello = await broker.call('greeter.sayHello')
        const hi = await broker.call('greeter.sayHai')
        console.log(`${hello} ${hi}`)
    }
    catch (err) {
        console.log(err)
    }
}
main()
.....................................................................................
			 Service Args and Parameters
.....................................................................................

Service apis can accept args, so that we can pass parameters.

Parameters can be primtive values or objects,arrays.


const hello = await broker.call('hello.sayHello',{name:'Subramanian'})

-Parameters must be encapsulated inside object only - {name:'subramanian'}


  actions: {
        sayHai(obj) {
            return 'Hai Moleculer!'
        }
    }

  sayGreet: {
            handler(obj) {
                return 'Greet!'
            }
        }

Context Object:
..............
-it is proxy object for broker meaning that, similar to broker.
-Most of the broker features are availble inside context object
-Context objects are created by moleculer automatically.
-We can grab context object reference inside actions method args
-Using context 
   -read parameters - ctx.params
   -you can call other service methods -  service communication. ctx.call
   -if you want to access broker information 


const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker();

broker.createService({
    name: 'hello',
    actions: {
        sayHello(ctx) {
            console.log(ctx)
            console.log(ctx.params)
            return `Hello ${ctx.params.name}`
        },
        //handler -meta pattern
        sayGreet: {
            handler(ctx) {
                return `Greet ${ctx.params.name}`
            }
        }
    }
})



async function main() {
    try {
        await broker.start()
        const res = await broker.call('hello.sayHello', { name: 'Subramanian' })
        console.log(res)
        const res1 = await broker.call('hello.sayGreet', { name: 'Subramanian' })
        console.log(res1)

    }
    catch (err) {
        console.log(err)
    }
}
main()
....................................................................................
		         Parameter Validation

Validation middleware is used for Actions and Events parameter validation.

Fastest Validator
By default, Moleculer uses the fastest-validator library.

Reference link: https://github.com/icebob/fastest-validator

const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker();

broker.createService({
    name: 'math',
    actions: {
        //validation
        add: {
            params: {
                a: { type: "number", positive: true, integer: true },
                b: { type: "number", positive: true, integer: true }
            },
            handler(ctx) {
                return ctx.params.a + ctx.params.b
            }
        }
    }
})



async function main() {
    try {
        await broker.start()
        const res = await broker.call('math.add', { a: 10, b: 20 })
        console.log(`The Add Result is ${res}`)
       
      //const res1 = await broker.call('math.add', { a: 10.78, b: 20 })
        //const res1 = await broker.call('math.add', { a: '10', b: 20 })

        const res1 = await broker.call('math.add', { a: 10.78, b: 20 })

        console.log(`The Add Result is ${res1}`)

    }
    catch (err) {
        console.log(err)
    }
}
main()
.....................................................................................
			Sync and Async Services
.....................................................................................

const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker();

broker.createService({
    name: 'math',
    actions: {
        add: {
            params: {
                a: { type: "number", positive: true, integer: true },
                b: { type: "number", positive: true, integer: true }
            },
            handler(ctx) {
                //return promise
                return new this.Promise((resolve,reject)=>{
                    setTimeout(resolve,5000,(ctx.params.a + ctx.params.b))
                });
            }
        }
    }
})



async function main() {
    try {
        await broker.start()
        const res = await broker.call('math.add', { a: 10, b: 20 })
        console.log(`The Add Result is ${res}`)
     
    }
    catch (err) {
        console.log(err)
    }
}
main()
.....................................................................................
			 Moleculer REPL- Command line interactions
.....................................................................................

Objective:			
=>To Test Service apis dynamically with various parameters
=>For Administration of Services,actions,....

const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker();

broker.createService({
    name: 'math',
    actions: {
        add: {
            params: {
                a: { type: "number", positive: true, integer: true },
                b: { type: "number", positive: true, integer: true }
            },
            handler(ctx) {
                //return promise
                return new this.Promise((resolve,reject)=>{
                    setTimeout(resolve,5000,(ctx.params.a + ctx.params.b))
                });
            }
        }
    }
})



async function main() {
    try {
        await broker.start()
        console.log('Broker is Ready!')
        //Use Repl
        await broker.repl()
     
    }
    catch (err) {
        console.log(err)
    }
}
main()

when run the code,  you will get the following error
The 'moleculer-repl' package is missing. Please install it with 'npm install moleculer-repl' command.
[2022-05-26T05:13:24.308Z] ERROR laptop-r2tggfdl-25428/BROKER: The 'moleculer-repl' package is missing. Please install it with 'npm install moleculer-repl' command.
[

npm install moleculer-repl

node services/repl.service.js
[2022-01-06T05:25:33.524Z] INFO  laptop-r2tggfdl-24436/BROKER: Moleculer v0.14.18 is starting...
[2022-01-06T05:25:33.526Z] INFO  laptop-r2tggfdl-24436/BROKER: Namespace: <not defined>
[2022-01-06T05:25:33.527Z] INFO  laptop-r2tggfdl-24436/BROKER: Node ID: laptop-r2tggfdl-24436
[2022-01-06T05:25:33.530Z] INFO  laptop-r2tggfdl-24436/REGISTRY: Strategy: RoundRobinStrategy
[2022-01-06T05:25:33.531Z] INFO  laptop-r2tggfdl-24436/REGISTRY: Discoverer: LocalDiscoverer
[2022-01-06T05:25:33.537Z] INFO  laptop-r2tggfdl-24436/BROKER: Serializer: JSONSerializer
[2022-01-06T05:25:33.548Z] INFO  laptop-r2tggfdl-24436/BROKER: Validator: FastestValidator
[2022-01-06T05:25:33.550Z] INFO  laptop-r2tggfdl-24436/BROKER: Registered 13 middleware(s).
[2022-01-06T05:25:33.565Z] INFO  laptop-r2tggfdl-24436/REGISTRY: '$node' service is registered.
[2022-01-06T05:25:33.567Z] INFO  laptop-r2tggfdl-24436/REGISTRY: 'math' service is registered.
[2022-01-06T05:25:33.568Z] INFO  laptop-r2tggfdl-24436/$NODE: Service '$node' started.
[2022-01-06T05:25:33.568Z] INFO  laptop-r2tggfdl-24436/MATH: Service 'math' started.
[2022-01-06T05:25:33.569Z] INFO  laptop-r2tggfdl-24436/BROKER: ✔ ServiceBroker with 2 service(s) is started successfully in 8ms.
Service Broker is ready
mol $ help

  Commands:

    help [command...]                                          Provides help for a given command.
    q                                                          Exit application
    actions [options]                                          List of actions
    bench [options] <action> [jsonParams] [meta]               Benchmark a service
    broadcast <eventName>                                      Broadcast an event
    broadcastLocal <eventName>                                 Broadcast an event locally
    cache keys [options]                                       List keys of cache entries
    cache clear [pattern]                                      Clear cache entries
    call [options] <actionName> [jsonParams] [meta]            Call an action
    dcall [options] <nodeID> <actionName> [jsonParams] [meta]  Direct call an action
    clear [pattern]                                            Clear cache entries
    cls                                                        Clear console
    destroy <serviceName> [version]                            Destroy a local service
    emit <eventName>                                           Emit an event
    env                                                        List of environment variables
    events [options]                                           List of event listeners
    info                                                       Information about broker
    load <servicePath>                                         Load a service from file
    loadFolder <serviceFolder> [fileMask]                      Load all services from folder
    metrics [options]                                          List metrics
    nodes [options]                                            List of nodes
    services [options]                                         List of services

mol $

..........................

List services,actions,info:
.............................

services
╔═════════╤═════════╤══════════╤═════════╤════════╤═══════╗
║ Service │ Version │    State │ Actions │ Events │ Nodes ║
╟─────────┼─────────┼──────────┼─────────┼────────┼───────╢
║ $node   │       - │    OK    │       7 │      0 │ 1     ║
║ math    │       - │    OK    │       1 │      0 │ 1     ║
╚═════════╧═════════╧══════════╧═════════╧════════╧═══════╝

 actions
╔════════════════╤═══════╤══════════╤════════╤═══════════════════════════════════════════════════════════════════════════╗
║ Action         │ Nodes │ State    │ Cached │ Params                                                                    ║
╟────────────────┼───────┼──────────┼────────┼───────────────────────────────────────────────────────────────────────────╢
║ $node.actions  │ (*) 1 │    OK    │   No   │ onlyLocal, skipInternal, withEndpoints, onlyAvailable                     ║
║ $node.events   │ (*) 1 │    OK    │   No   │ onlyLocal, skipInternal, withEndpoints, onlyAvailable                     ║
║ $node.health   │ (*) 1 │    OK    │   No   │                                                                           ║
║ $node.list     │ (*) 1 │    OK    │   No   │ withServices, onlyAvailable                                               ║
║ $node.metrics  │ (*) 1 │    OK    │   No   │ types, includes, excludes                                                 ║
║ $node.options  │ (*) 1 │    OK    │   No   │                                                                           ║
║ $node.services │ (*) 1 │    OK    │   No   │ onlyLocal, skipInternal, withActions, withEvents, onlyAvailable, grouping ║
╟────────────────┼───────┼──────────┼────────┼───────────────────────────────────────────────────────────────────────────╢
║ math.add       │ (*) 1 │    OK    │   No   │ a, b                                                                      ║
╚════════════════╧═══════╧══════════╧════════╧═══════════════════════════════════════════════════════════════════════════╝

info

=======================
  General information
=======================

    CPU                      : Arch: x64, Cores: 12
    Memory                   : [||||||-------------] 47.6 GB free
    Heap                     : [-------------------] 15.9 MB
    OS                       : win32 (Windows_NT)
    IP                       : 192.168.48.1, 172.25.48.1, 192.168.0.105
    Hostname                 : LAPTOP-R2TGGFDL

    Node version             : v14.17.0
    Moleculer version        : 0.14.18
    Protocol version         : 4

    Current time             : Thu Jan 06 2022 10:56:42 GMT+0530 (India Standard Time)

======================
  Broker information
======================

    Namespace                : <None>
    Node ID                  : laptop-r2tggfdl-24436
    Services                 : 2
    Actions                  : 8
    Events                   : 0

    Strategy                 : RoundRobinStrategy
    Cacher                   : <None>

==================
  Broker options
==================

    namespace                : ""
    logger                   : true
    requestTimeout           : 0
    retryPolicy
      enabled                : false
      retries                : 5
      delay                  : 100
      maxDelay               : 1000
      factor                 : 2
      check                  : [Function check]
    contextParamsCloning     : false
    maxCallLevel             : 0
    heartbeatInterval        : 10
    heartbeatTimeout         : 30
    tracking
      enabled                : false
      shutdownTimeout        : 5000
    disableBalancer          : false
    registry
      strategy               : "RoundRobin"
      preferLocal            : true
    circuitBreaker
      enabled                : false
      threshold              : 0.5
      windowTime             : 60
      minRequestCount        : 20
      halfOpenTime           : 10000
      check                  : [Function check]
    bulkhead
      enabled                : false
      concurrency            : 10
      maxQueueSize           : 100
    transit
      maxQueueSize           : 50000
      maxChunkSize           : 262144
      disableReconnect       : false
      disableVersionCheck    : false
    validator                : true
    metrics                  : false
    tracing                  : false
    internalServices         : true
    internalMiddlewares      : true
    dependencyInterval       : 1000
    hotReload                : false
    metadata
    skipProcessEventRegistration: false

mol $

Service calls using Repl:
.........................

call math.add --a 10 --b 20
>> Call 'math.add' with params: { a: 10, b: 20 }
{ a: 10, b: 20 }
>> Execution time:4ms
>> Response:
30
mol $ call math.add --a 10 --b 50
>> Call 'math.add' with params: { a: 10, b: 50 }
{ a: 10, b: 50 }
>> Execution time:1ms
>> Response:
60
mol $
.....................................................................................

				Methods Types

/////////////////////////////////////////////////////////////////////////////////////////////

Service Methods:

1.public methods
    methods are accssiable outside 
2.private methods
  methods are not accssible outside
  methods are used to isloate complex logic from public methods.


public methods:
 any thing if you write inside actions are called public methods.

actions { 


}

private methods:

createService({

 //public methods
 actions: {

 },

 //private methods
 methods: {


 }

})
const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker();

broker.createService({
    name: 'math',
    actions: {
        add: {
            params: {
                a: { type: "number", positive: true, integer: true },
                b: { type: "number", positive: true, integer: true }
            },
            handler(ctx) {
                //call private method
                return this.add(ctx)
            }
        },
        multiply: {
            params: {
                a: { type: "number", positive: true, integer: true },
                b: { type: "number", positive: true, integer: true }
            },
            handler(ctx) {
                //call private method
                return this.multiply(ctx)
            }
        }
    },
    //private methods
    methods: {
        add(ctx) {
            return ctx.params.a + ctx.params.b
        },
        multiply(ctx) {
            return ctx.params.a * ctx.params.b
        }
    }
})



async function main() {
    try {
        await broker.start()
        console.log('Broker is Ready!')
        //Use Repl
        await broker.repl()

    }
    catch (err) {
        console.log(err)
    }
}
main()
...................................................................................
			  Service Life Cycle methods
...................................................................................

Service life cycle methods are called by broker in various stages of services

Service life cycle methods are very usefull for doing some initalization, re initalizations tasks.

1. created() {
        // Fired when the service instance created (with `broker.loadService` or `broker.createService`)
    },

    merged() {
        // Fired after the service schemas merged and before the service instance created
    },
    
    async started() {
        // Fired when broker starts this service (in `broker.start()`)
    }

    async stopped() {
        // Fired when broker stops this service (in `broker.stop()`)
    }

const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker();

broker.createService({
    name: 'math',
    //public methods
    actions: {
        add: {
            params: {
                a: { type: "number", positive: true, integer: true },
                b: { type: "number", positive: true, integer: true }
            },
            handler(ctx) {
                //call private method
                return this.add(ctx)
            }
        },
        multiply: {
            params: {
                a: { type: "number", positive: true, integer: true },
                b: { type: "number", positive: true, integer: true }
            },
            handler(ctx) {
                //call private method
                return this.multiply(ctx)
            }
        }
    },
    //private methods
    methods: {
        add(ctx) {
            return ctx.params.a + ctx.params.b
        },
        multiply(ctx) {
            return ctx.params.a * ctx.params.b
        }
    },
    //Life cycle methods
    created() {
        console.log('Service Created')
    },
    merged() {
        // Fired after the service schemas merged and before the service instance created
        console.log('Service merged')
    },

    async started() {
        // Fired when broker starts this service (in `broker.start()`)
        console.log('Service started')
    },
    async stopped() {
        // Fired when broker stops this service (in `broker.stop()`)
        console.log('Service stoped')
    }
})



async function main() {
    try {
        await broker.start()
        console.log('Broker is Ready!')
        //Use Repl
        await broker.repl()

    }
    catch (err) {
        console.log(err)
    }
}
main()
....................................................................................
				Service Dependencies
....................................................................................
Dependencies
  If your service depends on other services, use the dependencies property in the schema. 
The service waits for dependent services before calls the started lifecycle event handler.

Syntax:

dependencies: [
      "likes", // shorthand w/o version
      "v2.auth", // shorthand w version
      { name: "users", version: 2 }, // with numeric version
      { name: "comments", version: "staging" } // with string version
],
async started() {
      console.log("It will be called after all dependent services are available.");
      const users = await this.broker.call("users.list");
}
const { ServiceBroker } = require("moleculer")

const broker = new ServiceBroker();

broker.createService({
    name: 'comments',
    actions: {
        findAll() {
            return 'Comments'
        }
    },
    //Dependency
    dependencies: [
        "posts"
    ],
    //Life cycle methods
    created() {
        console.log('Comments Service Created')
    },
    merged() {
        // Fired after the service schemas merged and before the service instance created
        console.log('Comments Service merged')
    },

    async started() {
        // Fired when broker starts this service (in `broker.start()`)
        console.log('Comments Service started')
    },
    async stopped() {
        // Fired when broker stops this service (in `broker.stop()`)
        console.log('Comments Service stoped')
    },

})

broker.createService({
    name: 'posts',
    actions: {
        findAll() {
            return [{ id: 1, name: 'Microservices' }]
        }
    },
    //Life cycle methods
    created() {
        console.log('Posts Service Created')
    },
    merged() {
        // Fired after the service schemas merged and before the service instance created
        console.log('Posts Service merged')
    },

    async started() {
        // Fired when broker starts this service (in `broker.start()`)
        console.log('Posts Service started')
    },
    async stopped() {
        // Fired when broker stops this service (in `broker.stop()`)
        console.log('Posts Service stoped')
    }
})


async function main() {

    try {
        await broker.start()
        console.log('Service Broker is ready')
        await broker.repl()

    } catch (error) {
        console.log(error)
    }
}
main();


Comments Service merged
Comments Service Created
Posts Service merged
Posts Service Created
[2022-05-26T06:24:57.895Z] INFO  laptop-r2tggfdl-17028/COMMENTS: Waiting for service(s) 'posts'...
Posts Service started
[2022-05-26T06:24:57.906Z] INFO  laptop-r2tggfdl-17028/REGISTRY: '$node' service is registered.
[2022-05-26T06:24:57.908Z] INFO  laptop-r2tggfdl-17028/REGISTRY: 'posts' service is registered.
[2022-05-26T06:24:57.908Z] INFO  laptop-r2tggfdl-17028/$NODE: Service '$node' started.
[2022-05-26T06:24:57.908Z] INFO  laptop-r2tggfdl-17028/POSTS: Service 'posts' started.
[2022-05-26T06:24:58.898Z] INFO  laptop-r2tggfdl-17028/COMMENTS: Service(s) 'posts' are available.
Comments Service started
....................................................................................
			 Service Code Reuse- Service Inheritance
....................................................................................

A Service has many options, those options may be repeated in many other services,
like common settings.
We can isloate common features / options into a separate service, we can reuse across multiple services -  Inheritance.

How to implement inheritance in moleculer?

Javascript can support only single inheritance, only one parent allowed for a child.

Java like languages support interfaces for multi parent patterns, javascript has no such facility.

Javascript has a design pattern and implementation ,called "mixin", through mixin we can inherit many super objects.

Moleculer has mixin property

Use case:
1.if you write any REST Controller.
2.if you write database operations inside your service.
etc...

const { ServiceBroker } = require('moleculer')
const broker = new ServiceBroker();

//parent Services
const hello = {
    name: 'hello',
    actions: {
        sayHello() {
            return 'Hello,From Parent';
        }
    }
}
const hai = {
    name: 'hai',
    actions: {
        sayHai() {
            return 'Hai, From Parent'
        }
    }
}
//Child Service
broker.createService({
    name: 'greeter',
    mixins: [hello, hai]
})



async function main() {
    try {
        await broker.start()
        broker.repl();
    }
    catch (err) {
        console.log(err);
    }

}
main();
...................................................................................
				Calling parent methods and coimbining
const { ServiceBroker } = require('moleculer')
const broker = new ServiceBroker();

//parent Services
const hello = {
    name: 'hello',
    actions: {
        sayHello() {
            return 'Hello,From Parent';
        }
    }
}
const hai = {
    name: 'hai',
    actions: {
        sayHai() {
            return 'Hai, From Parent'
        }
    }
}
//Child Service
broker.createService({
    name: 'greeter',
    mixins: [hello, hai],
    actions: {
        greet: {
            async handler(ctx) {
                return `${await this.actions.sayHai()} ${await this.actions.sayHello()}`
            }
        }
    }
})



async function main() {
    try {
        await broker.start()
        broker.repl();
    }
    catch (err) {
        console.log(err);
    }

}
main();
....................................................................................
		Defining Service Properties and How to override them

Service has 

1.methods called actions
2.properties which are defined inside settings
3.parent settings and actions can be overriden inside child service.

const { ServiceBroker } = require('moleculer')
const broker = new ServiceBroker();

//simulating some webserver settings

const webServer = {
    name: 'webserver',
    //parent properties
    settings: {
        port: 8080,
        host:'ibm.com'
    }
}

//parent Services
const hello = {
    name: 'hello',
    actions: {
        sayHello() {
            return 'Hello,From Parent';
        }
    }
}
const hai = {
    name: 'hai',
    actions: {
        sayHai() {
            return 'Hai, From Parent'
        }
    }
}
//Child Service
broker.createService({
    name: 'greeter',
    mixins: [hello, hai, webServer],
    //override parent properties
    settings: {
        port: 3000
    },
    actions: {
        greet: {
            handler(ctx) {
                return `WebServer Port is ${this.settings.port} Host ${this.settings.host}`
            }
        },
        sayHello(){
            return 'Child Overriding Hello'
        }
    }
})



async function main() {
    try {
        await broker.start()
        broker.repl();
    }
    catch (err) {
        console.log(err);
    }

}
main();
...................................................................................
				Types of Services

Moleculer Provides two types of service

1.Custom Services
   The services are created with broker object
2.Built services
  The services are provided by Broker
 $node
   Used for administration

How to list all services using $node
 call $node.services
>> Call '$node.services' with params: {} with meta: { '$repl': true } with options: {}
>> Execution time:1ms
>> Response:
[
  {
    name: '$node',
    version: undefined,
    fullName: '$node',
    settings: {},
    metadata: {},
    local: true,
    available: true,
    nodes: [ 'laptop-r2tggfdl-17828' ]
  },
  {
    name: 'greeter',
    version: undefined,
    fullName: 'greeter',
    settings: { port: 3000, host: 'ibm.com' },
    metadata: {},
    local: true,
    available: true,
    nodes: [ 'laptop-r2tggfdl-17828' ]
  }
]

$ call $node.list
>> Call '$node.list' with params: {} with meta: { '$repl': true } with options: {}
>> Execution time:1ms
>> Response:
[
  {
    id: 'laptop-r2tggfdl-17828',
    instanceID: 'c7fd8078-2bf2-42ee-88f6-1fd20184eb3c',
    available: true,
    local: true,
    lastHeartbeatTime: 0,
    config: {},
    client: { type: 'nodejs', version: '0.14.21', langVersion: 'v16.15.0' },
    metadata: {},
    ipList: [ '172.26.240.1', '172.22.176.1', '192.168.0.105' ],
    port: null,
    hostname: 'LAPTOP-R2TGGFDL',
    udpAddress: null,
    cpu: null,
    cpuSeq: null,
    seq: 3,
    offlineSince: null
  }
]

broker.createService({})
.....................................................................................
			     Service Communication
.....................................................................................

Service Representation

1.rpc 
2.rest
3.graphql

Service communications

1.rpc to rpc

2.rest to rest

2.rest to rpc


Moleculer is microservice, generally microservices may be distributed across multiple machines(nodes) , which communicates via networks.


1.Service communication with in single broker

2.Service communication across multiple service brokers

Communication style

1. can be sync
2. can be async

RPI style
   method to method call
Event driven style
   methods communicates via events.



Types of services:

1.local service
   service which is implemented on single broker.
2.remote service
   Service which is implemented across the brokers.
 
Services can communicate within service broker-single node arch
Services can communicate across service brokers - multi node arch

How services are interacting each other?

 Using "Context" Object

Actors:

 1.Caller service, who is calling /consuming other services

 2.Callee service, who is called by others

....................................................................................

Use case: RPC TO RPC , within single Broker(Single Node)
........................................................
const { ServiceBroker } = require('moleculer')
const broker = new ServiceBroker();

//math 
broker.createService({
    name: 'math',
    actions: {
        add: {
            handler(ctx) {
                //service calls 
                return ctx.call('adder.add', { a: ctx.params.a, b: ctx.params.b })
            }
        }
    }
})

//adder
broker.createService({
    name: 'adder',
    actions: {
        add: {
            handler(ctx) {
                return ctx.params.a + ctx.params.b
            }
        }
    }
})

async function main() {
    try {
        await broker.start()
        broker.repl();
    }
    catch (err) {
        console.log(err);
    }

}
main();
....................................................................................
				  Remote Service Communication
.....................................................................................

Microservices are loosly coupled services, runs indendently, how do they communicate

Remote Services
-Services are located across the nodes.
-nodes can be the same machine or different machines, or cloud.

Run two services in a different node.

node services/remote1.service.js

node services/remote2.service.js


Steps:

Open two cmd prompt

node services/remote1.service.js

node services/remote2.service.js


After Running you will get error like below

call math.add --a 10 --b 20
>> Call 'math.add' with params: { a: 10, b: 20 } with meta: { '$repl': true } with options: {}
[2022-05-26T09:55:49.122Z] WARN  laptop-r2tggfdl-13008/BROKER: Service 'adder.add' is not registered.
>> ERROR:
ServiceNotFoundError: Service 'adder.add' is not found.
    at ServiceBroker.findNextActionEndpoint (E:\session\IBM\2022\may\NodewithMS\myMoleculerApp\node_modules\moleculer\src\service-broker.js:1095:13)
    at ServiceBroker.call (E:\session\IBM\2022\may\NodewithMS\myMoleculerApp\node_modules\moleculer\src\service-broker.js:1144:26)
    at Context.call (E:\session\IBM\2022\may\NodewithMS\myMoleculerApp\node_modules\moleculer\src\context.js:286:23)
    at Service.handler (E:\session\IBM\2022\may\NodewithMS\myMoleculerApp\services\remot1.service.js:11:28)
    at E:\session\IBM\2022\may\NodewithMS\myMoleculerApp\node_modules\moleculer\src\utils.js:212:22
    at ServiceBroker.timeoutMiddleware (E:\session\IBM\2022\may\NodewithMS\myMoleculerApp\node_modules\moleculer\src\middlewares\timeout.js:31:14)
    at ServiceBroker.fallbackMiddleware (E:\session\IBM\2022\may\NodewithMS\myMoleculerApp\node_modules\moleculer\src\middlewares\fallback.js:31:11)
    at ServiceBroker.errorHandlerMiddleware (E:\session\IBM\2022\may\NodewithMS\myMoleculerApp\node_modules\moleculer\src\middlewares\error-handler.js:14:10)
    at ServiceBroker.call (E:\session\IBM\2022\may\NodewithMS\myMoleculerApp\node_modules\moleculer\src\service-broker.js:1168:31)
    at handler (E:\session\IBM\2022\may\NodewithMS\myMoleculerApp\node_modules\moleculer-repl\src\commands\call.js:131:28)

Why the above error?

-Service not able to locate the other service, since other services are running in different nodes

In order to enable Remote Service communications , we need Transporters

Transporter is a channel and bridge layer among services.


In order to enable Remote Service communications , we need Message Brokers 


Transporters:

-Transporter is an important module if you are running services on multiple nodes. 

-Transporter communicates with other nodes. 

-It transfers events, calls requests and processes responses …etc. 

-If a service runs on multiple instances on different nodes, the requests will be load-balanced among live nodes.


Transports:
............

Built-in transporter
TCP transporter - part of moleculer

Third party Brokers

NATS Transporter
Redis Transporter
MQTT Transporter
AMQP Transporter
Kafka Transporter
NATS Streaming (STAN) Transporter

TCP transporter:

This is a no-dependency, zero-configuration TCP transporter.
It uses Gossip protocol to disseminate node statuses, service list and heartbeats.
It contains an integrated UDP discovery feature to detect new and disconnected nodes on the network.
If the UDP is prohibited on your network, use urls option. It is a list of remote endpoints (host/ip, port, nodeID). It can be a static list in your configuration or a file path which contains the list.

Use case :How to use TCP transport as channel for service Communications.

We need to configure Service Broker to enable transpoert.

ServiceBroker object creation:

const broker = new ServiceBroker();
 Here we have not passed any parameter to ServiceBroker Constructor, if you dont, the default parameters will be passed.

Service Broker Parameters are called as "ServiceBroker Schema"

We can override service Broker Schema to enable broker vide features.

const { ServiceBroker } = require('moleculer')
const broker = new ServiceBroker({
    transporter:"TCP"
});

Eg:

remote1.service.js
const { ServiceBroker } = require('moleculer')
const broker = new ServiceBroker({
    transporter:"TCP"
});

//math 
broker.createService({
    name: 'math',
    actions: {
        add: {
            handler(ctx) {
                //service calls 
                return ctx.call('adder.add', { a: ctx.params.a, b: ctx.params.b })
            }
        }
    }
})

async function main() {
    try {
        await broker.start()
        broker.repl();
    }
    catch (err) {
        console.log(err);
    }

}
main();

remote2.service.js
const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker({
    nodeID : 'IBM-Adder Service',
    transporter:"TCP"
});

//adder
broker.createService({
    name: 'adder',
    actions: {
        add: {
            handler(ctx) {
                return `${broker.nodeID} -> ${ctx.params.a} + ${ctx.params.b}`
            }
        }
    }
})

async function main() {
    try {
        await broker.start()
        broker.repl();
    }
    catch (err) {
        console.log(err);
    }

}
main();

call math.add --a 10 --b 20
>> Call 'math.add' with params: { a: 10, b: 20 } with meta: { '$repl': true } with options: {}
>> Execution time:3ms
>> Response:
'IBM-Adder Service -> 10 + 20'
.....................................................................................
			      Service communication via 
		   Third party brokers - NATS,Redis,RabbitMQ,Kaffka


NATS:
Steps:
1.You need to start NATS server.
https://nats.io/download/

docker run -p 4222:4222 -ti nats:latest


2.configure in service broker

const broker = new ServiceBroker({
    nodeID : 'IBM-Adder Service',
    transporter: "nats://localhost:4222"
});

3.install nats dirver package
npm install nats --save

4.Run nodes as usual
....................................................................................
				Serialization

Transporter needs a serializer module which serializes & deserializes the transferred packets. 
The default serializer is the JSONSerializer but there are several built-in serializer.

const { ServiceBroker } = require('moleculer')


const broker = new ServiceBroker({
  //  transporter:"TCP"
  transporter: "nats://localhost:4222",
  serializer: "JSON" // not necessary to set, because it is the default

});

//math 
broker.createService({
    name: 'customer',
    actions: {
        list: {
            handler(ctx) {
                //service calls 
                return ctx.call('product.list')
            }
        }
    }
})

async function main() {
    try {
        await broker.start()
        broker.repl();
    }
    catch (err) {
        console.log(err);
    }

}
main();

const { ServiceBroker } = require('moleculer')
const products = require('../mock-data/products')

const broker = new ServiceBroker({
    transporter: "nats://localhost:4222",
    serializer: "JSON" // not necessary to set, because it is the default

});

//adder
broker.createService({
    name: 'product',
    actions: {
        list: {
            handler(ctx) {
                return products
            }
        }
    }
})

async function main() {
    try {
        await broker.start()
        broker.repl();
    }
    catch (err) {
        console.log(err);
    }

}
main();

.....
Runnin

node services/productremote.js

node services/customerremote.js
.....................................................................................
			Loosly Coupled Service Communication
				Event Driven Archs
			 How to communicate via events
....................................................................................

Broker has a built-in event bus to support Event-driven architecture and to send events to local and remote services.


Callee: Events Listeners

   events: {
        "order.created": {
            handler(ctx) {
                console.log("Payload:", ctx.params);
                console.log("Sender:", ctx.nodeID);
                console.log("Metadata:", ctx.meta);
                console.log("The called event name:", ctx.eventName);
            }
        }
    }
   

callee : Event emission

 broker/ctx.emit("order.created",{order:{id:1,name:'test'}}) - one to one
 broker/ctx.broadcast("order.created",{order:{id:1,name:'test'}}) - one to many


publisher.service.js
const { ServiceBroker } = require("moleculer")

const broker = new ServiceBroker({
    transporter: "TCP"
});

broker.createService({
    name: 'math',
    actions: {
        add: {
            handler(ctx) {
                // ctx.emit("adder.add", { a: ctx.params.a, b: ctx.params.b })
                ctx.broadcast("adder.add", { a: ctx.params.a, b: ctx.params.b })

                return 'Event has emitted'
            }
        }
    }
})

async function main() {

    try {
        await broker.start()
        console.log('Service Broker is ready')
        broker.repl();
    } catch (error) {
        console.log(error)
    }
}
main();

listener.service.js
const { ServiceBroker } = require("moleculer")

const broker = new ServiceBroker({
    transporter: "TCP"
});

broker.createService({
    name: 'adder',
    events: {
        "adder.add": {
            params: {
                a: "number",
                b: "number"
            },
            handler(ctx){
                console.log("Payload:", ctx.params);
                console.log("Sender:", ctx.nodeID);
                console.log("Metadata:", ctx.meta);
                console.log("The called event name:", ctx.eventName);
            }
        }
    }
})

async function main() {

    try {
        await broker.start()
        console.log('Service Broker is ready')
        broker.repl();
    } catch (error) {
        console.log(error)
    }
}
main();

listener2.service.js
const { ServiceBroker } = require("moleculer")

const broker = new ServiceBroker({
    transporter: "TCP"
});

broker.createService({
    name: 'math',
    actions: {
        add: {
            handler(ctx) {
                // ctx.emit("adder.add", { a: ctx.params.a, b: ctx.params.b })
                ctx.broadcast("adder.add", { a: ctx.params.a, b: ctx.params.b })

                return 'Event has emitted'
            }
        }
    }
})

async function main() {

    try {
        await broker.start()
        console.log('Service Broker is ready')
        broker.repl();
    } catch (error) {
        console.log(error)
    }
}
main();
*********************************************&&&&&&&&&&&&*************************
			   REST API Design
..................................................................................
Moleculer Modules:
..................

Moleculer core lib provides only how to create backend services, service interactions.

If i want to integrate lets say, rest api,databases, then we have to look at moleculer modules.

1.Gateways
2.Database and stores
3.Metrics & Tracing 
4.General 
5.Security
6.Tasks&Queues
7.Jobs
etc...

1.GateWay : moleculer-web:Official API Gateway for Moleculer framework.

npm install moleculer-web --save

Features:

support HTTP & HTTPS
serve static files
multiple routes
support global, route, alias middlewares
support file uploading
alias names (with named parameters & REST shorthand)
whitelist
multiple body parsers (json, urlencoded)
CORS headers
ETags
HTTP2
Rate limiter
before & after call hooks
Buffer & Stream handling
middleware mode (use as a middleware in ExpressJS Application)
support authorization and auth


GateWay is entry point to microservices apps

How to create web server and start ?

const { ServiceBroker } = require('moleculer');
const ApiGateWay = require('moleculer-web')

const broker = new ServiceBroker({
    transporter: 'TCP'
})

//GateWayService
broker.createService({
    name: 'ApiGateWay',
    mixins: [ApiGateWay]
})

async function main() {
    await broker.start();
}
main();

27T04:59:20.137Z] INFO  laptop-r2tggfdl-20548/APIGATEWAY: API Gateway server created.
[2022-05-27T04:59:20.138Z] INFO  laptop-r2tggfdl-20548/APIGATEWAY: Register route to '/'
[2022-05-27T04:59:20.161Z] INFO  laptop-r2tggfdl-20548/APIGATEWAY:
[2022-05-27T04:59:20.163Z] INFO  laptop-r2tggfdl-20548/TRANSIT: Connecting to the transporter...
[2022-05-27T04:59:20.165Z] INFO  laptop-r2tggfdl-20548/TRANSPORTER: TCP server is listening on port 62707
[2022-05-27T04:59:20.185Z] INFO  laptop-r2tggfdl-20548/TRANSPORTER: UDP Multicast Server is listening on 172.26.240.1:4445. Membership: 239.0.0.0
[2022-05-27T04:59:20.186Z] INFO  laptop-r2tggfdl-20548/TRANSPORTER: UDP Multicast Server is listening on 172.22.176.1:4445. Membership: 239.0.0.0
[2022-05-27T04:59:20.186Z] INFO  laptop-r2tggfdl-20548/TRANSPORTER: UDP Multicast Server is listening on 192.168.0.105:4445. Membership: 239.0.0.0
[2022-05-27T04:59:20.187Z] INFO  laptop-r2tggfdl-20548/TRANSPORTER: UDP Multicast Server is listening on 127.0.0.1:4445. Membership: 239.0.0.0
[2022-05-27T04:59:20.189Z] INFO  laptop-r2tggfdl-20548/TRANSPORTER: UDP discovery started.
[2022-05-27T04:59:20.189Z] INFO  laptop-r2tggfdl-20548/TRANSPORTER: TCP Transporter started.
[2022-05-27T04:59:20.697Z] INFO  laptop-r2tggfdl-20548/REGISTRY: '$node' service is registered.
[2022-05-27T04:59:20.698Z] INFO  laptop-r2tggfdl-20548/$NODE: Service '$node' started.
[2022-05-27T04:59:20.699Z] INFO  laptop-r2tggfdl-20548/APIGATEWAY: API Gateway listening on http://localhost:3000
[2022-05-27T04:59:20.701Z] INFO  laptop-r2tggfdl-20548/REGISTRY: 'ApiGateWay' service is registered.
[2022-05-27T04:59:20.702Z] INFO  laptop-r2tggfdl-20548/APIGATEWAY: Service 'ApiGateWay' started.
[2022-05-27T04:59:20.703Z] INFO  laptop-r2tggfdl-20548/BROKER: ✔ ServiceBroker with 2 service(s) started successfully in 541ms.
[2022-05-27T05:00:26.295Z] INFO  laptop-r2tggfdl-20548/APIGATEWAY: => GET /
[2022-05-27T05:00:38.356Z] INFO  laptop-r2tggfdl-20548/APIGATEWAY: <= 404 GET / [+12.062 s]
[2022-05-27T05:00:38.515Z] INFO  laptop-r2tggfdl-20548/APIGATEWAY: => GET /favicon.ico
[2022-05-27T05:00:38.516Z] WARN  laptop-r2tggfdl-20548/BROKER: Service 'favicon.ico' is not registered.
[2022-05-27T05:00:38.519Z] INFO  laptop-r2tggfdl-20548/APIGATEWAY: <= 404 GET /favicon.ico [+4.184 ms]
.............

How to call backend service(rpc service) from the GateWay Service?

http://localhost:3000/servicename/methodname
http://localhost:3000/greeter/sayHello
http://localhost:3000/hello/sayHello

const { ServiceBroker } = require('moleculer');
const ApiGateWay = require('moleculer-web')

const broker = new ServiceBroker({
    transporter: 'TCP'
})

//GateWayService
broker.createService({
    name: 'ApiGateWay',
    mixins: [ApiGateWay]
})

//http://localhost:3000/greeter/sayHello
//rpc service : Holding biz logic
broker.createService({
    name: 'greeter',
    actions: {
        sayHello: {
            handler(ctx) {
                return 'Hello GateWay Service'
            }
        }
    }
})

async function main() {
    await broker.start();
}
main();

..................................................................................
		   How to run distributed gateway service

gatewaytorpc.js
const { ServiceBroker } = require('moleculer');
const ApiGateWay = require('moleculer-web')
const products = require('../mock-data/products')

const broker = new ServiceBroker({
    transporter: 'TCP'
})

//GateWayService
broker.createService({
    name: 'ApiGateWay',
    mixins: [ApiGateWay]
})

//http://localhost:3000/greeter/sayHello
//rpc service : Holding biz logic
broker.createService({
    name: 'greeter',
    actions: {
        sayHello: {
            handler(ctx) {
                return 'Hello GateWay Service'
            }
        }
    }
})


async function main() {
    await broker.start();
}
main();


productremote.service.js
const { ServiceBroker } = require('moleculer')
const products = require('../mock-data/products')

const broker = new ServiceBroker({
    // transporter: "nats://localhost:4222",
    transporter:'TCP',
    serializer: "JSON" // not necessary to set, because it is the default

});

//adder
broker.createService({
    name: 'products',
    actions: {
        list: {
            handler(ctx) {
                return products
            }
        }
    }
})

async function main() {
    try {
        await broker.start()
        broker.repl();
    }
    catch (err) {
        console.log(err);
    }

}
main();

node services/gatwaytorpc.service.js
node services/productremote.service.js
....................................................................................
				Routers Configuration

const { ServiceBroker } = require('moleculer')
const ApiGateWay = require('moleculer-web')

const broker = new ServiceBroker({
    transporter: 'TCP',
    serializer: "JSON" // not necessary to set, because it is the default
});




//GateWayService
broker.createService({
    name: 'ApiGateWay',
    mixins: [ApiGateWay],
    //override ApiGateWayService properties
    settings: {
        routes: [{
            path: '/api'
        }, {
            path: '/admin'
        }]
    }
})

broker.createService({
    name: 'greeter',
    actions: {
        sayHello() {
            return 'Hello!';
        }
    }
})

broker.createService({
    name: 'admin',
    actions: {
        getAdmin() {
            return 'Admin!';
        }
    }
})

async function main() {
    await broker.start();
}
main();
.....................................................................................
.............................................................................................
    		How to restrict service method/actions access outside
				whiteList - configuration
.....................................................................................

const { ServiceBroker } = require('moleculer')
const ApiGateWay = require('moleculer-web')

const broker = new ServiceBroker({
    transporter: 'TCP'
});




//GateWayService
broker.createService({
    name: 'ApiGateWay',
    mixins: [ApiGateWay],
    //override ApiGateWayService properties
    settings: {
        routes: [{
            path: '/api',
            whitelist: [
                //Restrict to access only sayHello action
                "greeter.sayHello",
                //Restrict to access all actions in Greeter service
                //"greeter.*"
            ]
        },

        {
            path: '/admin'
        }]
    }
})

broker.createService({
    name: 'greeter',
    actions: {
        sayHello() {
            return 'Hello!';
        },
        sayHai() {
            return 'Hai!';
        },
        sayGreet() {
            return 'Greeter!';
        }
    }
})

broker.createService({
    name: 'admin',
    actions: {
        getAdmin() {
            return 'Admin!';
        }
    }
})

async function main() {
    await broker.start();
}
main();

URL Mapping in moleculer:

http://localhost:3000/api/serviceName/actionName

  This is not good way to map urls , which more difficult to remember, it is not user friendly
it is not even secure,the reason, we expose the back end service to end users.

Aliases:
........
  You can use aliases(dummyname/fakename)-Virtual path, instead of action name.

 settings: {
        routes: [
            {
                path: "/api",
                aliases: { 

                    "hello" : "greeter.hello",
                    "users" :  "users.list"
                }             
            }
        ]

http://localhost:3000/api/hello
http://localhost:3000/api/users

const { ServiceBroker } = require('moleculer')
const ApiGateWay = require('moleculer-web')

const broker = new ServiceBroker({
    transporter: 'TCP'
});

//http://localhost:3000/api/hello
//GateWayService
broker.createService({
    name: 'ApiGateWay',
    mixins: [ApiGateWay],
    //override ApiGateWayService properties
    settings: {
        routes: [{
            path: '/api',
            aliases: {
                "hello": "greeter.sayHello",
                "hi": "greeter.sayHai",
                "greet": "greeter.sayGreet",
                "products": "products.list"
            }
        },

        {
            path: '/admin'
        }]
    }
})

broker.createService({
    name: 'greeter',
    actions: {
        sayHello() {
            return 'Hello!';
        },
        sayHai() {
            return 'Hai!';
        },
        sayGreet() {
            return 'Greeter!';
        }
    }
})

broker.createService({
    name: 'admin',
    actions: {
        getAdmin() {
            return 'Admin!';
        }
    }
})

async function main() {
    await broker.start();
}
main();
.....................................................................................			HTTP Verbs Mapping - GET,POST,PUT,DELETE,PATCH
....................................................................................

aliases: {
   "GET users": "user.list",  //GET list is default method
   "GET users/:id": "user.get", //users/1 users/2 users/3
   "POST users": "user.create",
   "PUT users/:id": "user.update",
   "DELETE users/:id": "user.remove"
}

const { ServiceBroker } = require("moleculer");
const ApiGateWayService = require("moleculer-web");
const PRODUCTS = require('../mock-data/products')

const broker = new ServiceBroker();

//CURD service : 

broker.createService({
    name: 'products',
    actions: {
        //GET ALL products
        list: {
            handler(ctx) {
                return PRODUCTS;
            }
        },
        //GET product by id
        get: {
            handler(ctx) {
                console.log(ctx.params)
                return PRODUCTS.filter(product => product.id == ctx.params.id)
            }
        },
        //save
        create(ctx) {
            console.log(ctx.params)
            return 'Product Created'
        },
        //update
        update(ctx) {
            return 'Product updated'
        },
        //delete
        remove(ctx) {
            return 'Product removed'
        }
    }
})


broker.createService({
    name: 'APIGateWay',
    mixins: [ApiGateWayService],
    settings: {
        routes: [{
            path: '/api',
            aliases: {
                "GET products": "products.list",  //GET list is default method
                "GET products/:id": "products.get", //users/1 users/2 users/3
                "POST products": "products.create",
                "PUT products/:id": "products.update",
                "DELETE products/:id": "products.remove"
            }
        }]
    }
})


async function init() {
    try {
        await broker.start();
    }
    catch (e) {
        log(e);
    }
}
init();
.............................................................................................
SHORT Cut 


Without short cut
  aliases: {
                "GET users": "user.list",  //GET list is default method
                "GET users/:id": "user.get", //users/1 users/2 users/3
                "POST users": "user.create",
                "PUT users/:id": "user.update",
                "DELETE users/:id": "user.remove"
            }
With Short cut

it will map actions automatically but there is rule , method names should be like below
 aliases: { 
   "REST users" : "users"
 }

method names:
 list
 get
 create
 update
 remove


const { ServiceBroker } = require("moleculer");
const ApiGateWayService = require("moleculer-web");
const PRODUCTS = require('../mock-data/products')

const broker = new ServiceBroker();

//CURD service : 

broker.createService({
    name: 'products',
    actions: {
        //GET ALL products
        list: {
            handler(ctx) {
                return PRODUCTS;
            }
        },
        //GET product by id
        get: {
            handler(ctx) {
                console.log(ctx.params)
                return PRODUCTS.filter(product => product.id == ctx.params.id)
            }
        },
        //save
        create(ctx) {
            console.log(ctx.params)
            return 'Product Created'
        },
        //update
        update(ctx) {
            return 'Product updated'
        },
        //delete
        remove(ctx) {
            return 'Product removed'
        }
    }
})


broker.createService({
    name: 'APIGateWay',
    mixins: [ApiGateWayService],
    settings: {
        routes: [{
            path: '/api',
            aliases: {
                // "GET products": "products.list",  //GET list is default method
                // "GET products/:id": "products.get", //users/1 users/2 users/3
                // "POST products": "products.create",
                // "PUT products/:id": "products.update",
                // "DELETE products/:id": "products.remove"
                "REST products" : "products"
            }
        }]
    }
})


async function init() {
    try {
        await broker.start();
    }
    catch (e) {
        log(e);
    }
}
init();
Extra methods:



broker.createService({
    name: 'ApiGateWayService',
    mixins: [ApiGateWayService],
    settings: {
        routes: [
            {
                path: "/api",
                aliases: {
                    "REST users": "users",
                    "GET myapi"(req, res) {
                        // res.end("Hello This is my api")
                        res.end(JSON.stringify(USERS));
                    }
                }
            }
        ]
    }
})

async function init() {
    try {
        await broker.start();
    }
    catch (e) {
        log(e);
    }
}
....................................................................................
		  Convert any back end service into rest api
....................................................................................
				Auto aliases: without mapping rest api 
.....................................................................................
Actions can be converted into rest api.

      list:{
	  // /api/users/
	   rest : "GET /"       
	   handler(ctx){

	   }
        }

      get:{
	  // /api/users/
	   rest : "GET /:id"       
	   handler(ctx){

	   }
        }

      list:{
	  // /api/users/
	   rest : "POST /"       
	   handler(ctx){

	   }
        }			

const { ServiceBroker } = require("moleculer");
const ApiGateWayService = require("moleculer-web");
const PRODUCTS = require('../mock-data/products')

const broker = new ServiceBroker();

broker.createService({
    name: 'products',
    actions: {
        //GET ALL products
        list: {
            rest: "GET /",
            handler(ctx) {
                return PRODUCTS;
            }
        },
        //GET product by id
        get: {
            rest: "GET /:id",
            handler(ctx) {
                console.log(ctx.params)
                return PRODUCTS.filter(product => product.id == ctx.params.id)
            }
        },
        //save
        create: {
            rest: "POST /",
            handler(ctx) {
                console.log(ctx.params)
                return 'Product Created'
            }
        },
        //update
        update: {
            rest: "PUT /:id",
            handler(ctx) {
                console.log(ctx.params)
                return 'Product update'
            }
        },
        //delete
        remove: {
            rest: "DELETE /:id",
            handler(ctx) {
                console.log(ctx.params)
                return 'Product update'
            }
        }
    }
})


broker.createService({
    name: 'APIGateWay',
    mixins: [ApiGateWayService],
    settings: {
        routes: [{
            path: '/api',
            aliases: {
            },
            autoAliases: true
        }]
    }
})


async function main() {
    try {
        await broker.start();
    }
    catch (e) {
        log(e);
    }
}
main()

..............................................................................................
				    Middlewares
..............................................................................................
Middlewares are functions used for global functionality.
Middlewares are functions used for router level functionality.
..............................................................................................

Middlewares can be added globally and also router/alise level.

Global middlewares
settings : {
  use: [list of middlewares]
}
Router level middlewares

routes: [
  { 
    path:"/api",
    use: [list of middelwares]
  }
]
Note: you can use express related middlewares

const { ServiceBroker } = require("moleculer");
const ApiGateWayService = require("moleculer-web");
const USERS = require('./mock-data/users')
const cookieParser = require('cookie-parser')
const compression = require('compression')
const helmet = require("helmet");




const broker = new ServiceBroker();


broker.createService({
    name: "users",
    actions: {
        list: {
            rest: "GET /",
            handler(ctx) {
                return USERS;
            }
        },
        get: {
            rest: "GET /:id",
            handler(ctx) {
                return USERS.filter(user => user.id == ctx.params.id)
            }
        }
    }
})

//Frond End Service
//entry url configuration and action configuration - frond to back end configuration

broker.createService({
    name: 'ApiGateWayService',
    mixins: [ApiGateWayService],
    settings: {

        //global middlewares
        use: [
            cookieParser(),
            helmet()
        ],

        routes: [
            {
                path: "/api",
                //router middelware 
                use: [
                    compression()
                ],

                aliases: {

                },
                autoAliases: true
            }
        ]
    }
})

async function init() {
    try {
        await broker.start();
    }
    catch (e) {
        log(e);
    }
}
init();

const { ServiceBroker } = require("moleculer");
const ApiGateWayService = require("moleculer-web");
const PRODUCTS = require('../mock-data/products')
const cookieParser = require('cookie-parser')
const compression = require('compression')
const helmet = require("helmet");

const broker = new ServiceBroker();

broker.createService({
    name: 'products',
    actions: {
        //GET ALL products
        list: {
            rest: "GET /",
            handler(ctx) {
                return PRODUCTS;
            }
        },
        //GET product by id
        get: {
            rest: "GET /:id",
            handler(ctx) {
                console.log(ctx.params)
                return PRODUCTS.filter(product => product.id == ctx.params.id)
            }
        },
        //save
        create: {
            rest: "POST /",
            handler(ctx) {
                console.log(ctx.params)
                return 'Product Created'
            }
        },
        //update
        update: {
            rest: "PUT /:id",
            handler(ctx) {
                console.log(ctx.params)
                return 'Product update'
            }
        },
        //delete
        remove: {
            rest: "DELETE /:id",
            handler(ctx) {
                console.log(ctx.params)
                return 'Product update'
            }
        }
    }
})


broker.createService({
    name: 'APIGateWay',
    mixins: [ApiGateWayService],
    settings: {
        //global middlewares
        use: [
            cookieParser(),
            helmet()
        ],

        routes: [{
            path: '/api',
            use: [
                compression()
            ],
            aliases: {
            },
            autoAliases: true
        }]
    }
})


async function main() {
    try {
        await broker.start();
    }
    catch (e) {
        log(e);
    }
}
main()
.....................................................................................					How to handle Errors In moleculer


const { ServiceBroker } = require("moleculer");
const ApiGateWayService = require("moleculer-web");
const PRODUCTS = require('../mock-data/products')
const cookieParser = require('cookie-parser')
const compression = require('compression')
const helmet = require("helmet");

const broker = new ServiceBroker();

const { MoleculerError } = require("moleculer").Errors;


class MyBusinessError extends MoleculerError {
    constructor(msg, data) {
        super(msg || `This is my business error.`, 500, "MY_BUSINESS_ERROR", data);
    }
}


broker.createService({
    name: 'products',
    actions: {
        //GET ALL products
        list: {
            rest: "GET /",
            handler(ctx) {
                let isError = true;
                if (isError) throw new MyBusinessError();
                return PRODUCTS;
            }
        },
        //GET product by id
        get: {
            rest: "GET /:id",
            handler(ctx) {
                console.log(ctx.params)
                return PRODUCTS.filter(product => product.id == ctx.params.id)
            }
        },
        //save
        create: {
            rest: "POST /",
            handler(ctx) {
                console.log(ctx.params)
                return 'Product Created'
            }
        },
        //update
        update: {
            rest: "PUT /:id",
            handler(ctx) {
                console.log(ctx.params)
                return 'Product update'
            }
        },
        //delete
        remove: {
            rest: "DELETE /:id",
            handler(ctx) {
                console.log(ctx.params)
                return 'Product update'
            }
        }
    }
})


broker.createService({
    name: 'APIGateWay',
    mixins: [ApiGateWayService],
    settings: {
        //global middlewares
        use: [
            cookieParser(),
            helmet()
        ],
        // Global error handler
        onError(req, res, err) {
            res.setHeader("Content-Type", "text/plain");
            res.writeHead(501);
            res.end("Global error: " + err.message);
        },
        routes: [{
            path: '/api',
            use: [
                compression()
            ],
            aliases: {
            },
            autoAliases: true,
            // Route error handler
            onError(req, res, err) {
                res.setHeader("Content-Type", "application/json; charset=utf-8");
                res.writeHead(500);
                res.end(JSON.stringify({ err: err }));
            }
        }]
    }
})


async function main() {
    try {
        await broker.start();
    }
    catch (e) {
        log(e);
    }
}
main()

.......			Advanced Configurations

port,host,http2,https
.....................
settings: {
		// Exposed port
		port: 4000,

		// Exposed IP
		ip: "0.0.0.0",

		// HTTPS server with certificate
		https: {
			key: fs.readFileSync(path.join(__dirname, "../ssl/key.pem")),
			cert: fs.readFileSync(path.join(__dirname, "../ssl/cert.pem"))
		},

		//http2: true,

		// Global CORS settings
		cors: {
			origin: "*",
			methods: ["GET", "OPTIONS", "POST", "PUT", "DELETE"],
			allowedHeaders: "*",
			//exposedHeaders: "*",
			credentials: true,
			maxAge: null
		},

		// Rate limiter
		rateLimit: {
			window: 10 * 1000,
			limit: 10,
			headers: true
		},

		etag: true
}
....................................................................................
....................................................................................
			   Microservice Pattern : Data Management	
			       Database Per Service
..............................................................................................

According to Microservice pattern called "Database Per Service".

NeDb:
 In memormy and default database for Moleculer

Features:

-Default CURD operations
-Caching enabled
-pagination support
-Pluggable adapter - when even ever you want you can change database
-many adpaters supported
  -mongodb,postresql,sqllight,mysql,mssql.
-filtering supports
-encode and decode
-entity life cycle events


According to Microservice pattern called "Database Per Service".

const { ServiceBroker } = require("moleculer");
const ApiGateWayService = require("moleculer-web");
const DbService = require('moleculer-db')
const Fakerator = require('fakerator');
const { started } = require("moleculer-web");

//Fakerator object we need to create
const fakerator = new Fakerator();

const broker = new ServiceBroker({
    transporter: 'TCP'
});
//db service
broker.createService({
    name: 'users',
    mixins: [DbService],
    adapter: new DbService.MemoryAdapter(),
    //column mapping
    settings: {
        fields: ["_id", "firstName", "lastName", "email", "status"]
    },
     //life cycle method
     afterConnected() {
        //seeding the database with default data
        this.logger.info('connection started')
    },
    methods: {
        async seedDB() {
            this.logger.info('Seeding User Database starts');
            //generate fake users
            const fakeUsers = fakerator.times(fakerator.entity.user, 20);
            //insert into db
            const insertedUsers = await this.adapter.insertMany(fakeUsers);
            this.logger.info(`Created ${insertedUsers.length}`, insertedUsers)
        }
    },
     //service life cycle
     async started() {
        if ((await this.adapter.count()) === 0) {
            await this.seedDB();
        } else {
            this.logger.info(`DB contains ${await this.adapter.count()} users`)
        }
    }

})
broker.createService({
    name: 'ApiGateWayService',
    mixins: [ApiGateWayService],
    settings: {
        routes: [
            {
                path: "/api",
                aliases: {
                  "REST users": "users"  
                }
            }
        ]
    }
})


async function init() {
    try {
        await broker.start();
    }
    catch (e) {
        log(e);
    }
}
init();
......................................................................................


const { ServiceBroker } = require('moleculer')
const broker = new ServiceBroker()


broker.createService({
    name: 'greeter',
    actions: {
        sayGreet: {
            handler(ctx) {
                return "Hello"
            }
        }
    }
})


async function main() {
    try {
        await broker.start()
        await broker.repl()
    }
    catch (err) {
        console.log(err)
    }
}
main()
......................................................................................
/////////////////////////////////////////////////////////////////////////////////////////////
		              Service Registry and Discovery
.............................................................................................

1.Service Registry

 It is mini /small database , key-value pair database, in memory database.
 Which has all service,actions,event listeners, nodes information.

Points:
1.Every Broker has in built Service Registry
     Moleculer has built in in-memory registry, we can use that registry directly.

2.All services local or remote are registered with service registry as soon you create 
  service
3.Molecular has built in registry called LocalDiscoveryRegistry, which is not using third party registry servers
  like apache zoo keeper,cosule,etcd,eurka....

4.if you want to make other servers as service registry -

  registry: {
        discoverer: "redis://redis-server:6379"
    }  
const broker = new ServiceBroker({
registry: {
        discoverer: "redis://redis-server:6379"
    } 
});

What is discovery?
   
   Discovery  means the lookup, search, we are going to search "services" from the registry infra structure.

         "All Services when is created is registered in Service Registry"

Moleculer looks up services from the registry by name.
You can change registery server from LocalDiscover to Redis,etcd3,

1.Start Redis Server.

docker run  -p 6379:6379 redis

2.install redis driver
npm install ioredis --save

const broker = new ServiceBroker({
    transporter: "nats://localhost:4222",
    registry: {
        //discoverer:'Redis'
        discoverer: "redis://localhost:6379"
    }
});

[2021-07-31T08:44:43.219Z] INFO  laptop-r2tggfdl-24816/REGISTRY: Discoverer: RedisDiscoverer
....................................................................................
..............................................................................................
				High Availability and scalibity
..............................................................................................
			   	
 				  Load Balancing

In Server-side load balancing, the instances of the service are deployed on multiple servers and then a load balancer is put in front of them. It is generally a hardware load balancer. All the incoming requests traffic firstly comes to this load balancer acting as a middle component. It then decides to which server a particular request must be directed to based on some algorithm.

Disadvantages of Server-side load balancing:

Server side load balancer acts as a single point of failure as if it fails, all the instances of the microservice becomes inaccessible as only load balancer has the list of servers.

Since each microservice will have a separate load balancer, the overall complexity of the system increases and it becomes hard to manage.

The network latency increases as the number of hops for the request increases from one to two with the load balancer, one to the load balancer and then another from load balancer to the microservice.


2. Client-side Load Balancing

The instances of the service are deployed on multiple servers. Load balancer's logic is part of the client itself, it holds the list of servers and decides to which server a particular request must be directed to based on some algorithm. These client side load balancers are also known as software load balancers.

Disadvantages of Client-side load balancing
The load balancer's logic is mixed up with the microservice code.


............................

Server side Load balancer is very usefull to manage trafic from outside applications.
Mobile clients and webclients trafic easily can be managed.

Client side load balancers are very usefull to mangae trafic inside microservice application.


Why we need load balancer?

1. To scale services instances
 A single service may not sufficient to handle multiple concurrent request.

How to select which service instance to be assigned to caller(client), 

   With help of Load Balancer.

Load Balancer balances incomming load and route according to "router algorthims" provided by load balancers.


Built-in strategies

 ->RoundRobin strategy
	This strategy selects a node based on round-robin algorithm.
   Refer:https://en.wikipedia.org/wiki/Round-robin_DNS
 ->Random strategy
	This strategy selects a node randomly.
 ->CPU usage-based strategy
	This strategy selects a node which has the lowest CPU usage. Due to the node list can 	be very long, it gets samples and selects the node with the lowest CPU usage from only 	samples instead of the whole node list.

 ->Latency-based strategy
	This strategy selects a node which has the lowest latency, measured by periodic ping commands. Notice that the strategy only ping one of nodes from a single host.

In Moleculer load balancers are built in, part of Registry , which is part of broker.

Moleculer loader balancer by default uses RoundRobin algorthim, if you want to change different one, you can override

 registry: {
        strategy: "Latency",
        strategyOptions: {
            sampleCount: 15,
            lowLatency: 20,
            collectCount: 10,
            pingInterval: 15
        }
    }

How to implement load balancing?

1.You need to clone the services n- number of times.
  lets say i have service called "adder" service , i need to run adder service 2 instances

2.Each service is going to run in different nodes. Each node must be identified quickly.
  Node name should not be hardcoded.
  In Genernal Node Id would be  - computername_processId

Steps:

1.Front End
const { ServiceBroker } = require('moleculer')
const ApiGateWayService = require("moleculer-web");

const broker = new ServiceBroker({
    //nodeID: - machineName-processId
    transporter: 'TCP',
    //load balancer configuration
    registry: {
        discoverer: 'LOCAL', //type of registry
        strategy: 'RoundRobin' //load balancer algorthim
    }
})
//back end service
broker.createService({
    name: 'math',
    actions: {
        get: {
            rest: "GET /math",
            handler(ctx) {
                return ctx.call('adder.add', { a: ctx.params.a, b: ctx.params.b })
            }
        }
    }
})

broker.createService({
    name: 'ApiGateWayService',
    mixins: [ApiGateWayService],
    settings: {
        routes: [
            {
                path: "/api",
                aliases: {

                },
                autoAliases: true
            }
        ]
    }
})

async function main() {
    try {
        await broker.start()
        broker.repl();
    }
    catch (err) {
        console.log(err);
    }

}
main();

2.Back End Program - run two copies and enable loadbalancing
const { ServiceBroker } = require('moleculer')

const broker = new ServiceBroker({
    //nodeID: - machineName-processId
    transporter: 'TCP',
    //load balancer configuration
    registry: {
        discoverer: 'LOCAL', //type of registry
        strategy: 'RoundRobin' //load balancer algorthim
    }
})
//back end service
broker.createService({
    name: 'adder',
    actions: {
        add: {
            handler(ctx) {
                const { a,b } = ctx.params;
                return `${a + b} from ${broker.nodeID}`;
            }
        }
    }
})

async function main() {
    try {
        await broker.start()
        broker.repl();
    }
    catch (err) {
        console.log(err);
    }

}
main();


How to test?

1.open 4 cmd 

1st for front end
node services/api.loadbalancer.js

2.open 3 cmd and run the following cmd

node services/math.loadbalancer.js
node services/math.loadbalancer.js
node services/math.loadbalancer.js


open browser and test

http://localhost:3000/api/mathrest/math
....................................................................................
.............................&&&&&&&&&&&&&&...................................................
			 Microservices Pattern: Realiability
..............................................................................................

In Microservices, services are talking each other, while talking there are possiblity.

A. Callee Service may slow than expected duration by caller. - Slow calls

B. Callee may throw error , then caller gets exception which will be progataged across the app
   which may stop the entire app.

How to deal / solve the problem of above one ?

   Via Realibility pattern, we can solve the Problem.

Moleculer Provides Fault tolerance , through which we can solve
 

-Timeout

    Service-X  is calling Service-Y

1.You may get Result(succees/errors) "on time".

2.YOu may not get any thing beyond time.

3.Timeout defines deadlines for services


eg:
   Service-X expects result in 500 ms from Service-Y, What if Service-Y not able to give result within that time line , Service-Y will throw TimeoutException.

Now you need to decide how to Handle TimeoutException?

 -throw exception and handle it
 -You can have alternate fallback api to return result to the caller.


Any falut tolerence alogorthim in moleculer can be configured in two places

1.At broker level
const broker = new ServiceBroker({
    requestTimeout: 5 * 1000 // in milliseconds
});

2.At service level

broker.call("posts.find", {}, { timeout: 3000 });

services/timeoutmain.service.js
const { ServiceBroker } = require('moleculer');

const broker = new ServiceBroker({
    transporter: "TCP",
    requestTimeout: 5 * 1000 // in milliseconds

});
broker.createService({
    name: 'main',
    actions: {

        begin: {
            // Call the 'getCachedResult' method when error occurred
            fallback: "getCachedResult",
            async handler(ctx) {
                const { a, b, timeout } = ctx.params
                let res = await ctx.call('remotetimeout.calculate', { a, b }, {
                    timeout: timeout
                })
                console.log(`Result Got From Remote Services ${res}`)
            }
        }

    },
    methods: {
        getCachedResult() {
            return `From the Cache 0`
        }
    }
})
async function init() {
    await broker.start()
    broker.repl()
}
init();

services/remotetimeout.service.js
const { ServiceBroker } = require('moleculer');

const broker = new ServiceBroker({
    transporter: "TCP",
    requestTimeout: 5 * 1000 // in milliseconds
});

broker.createService({
    name: 'remotetimeout',
    actions: {
        async calculate(ctx) {
            const { a, b } = ctx.params
            return new Promise((resolve, reject) => {
                setTimeout(resolve, 3000, `${a + b} - ${broker.nodeID} `)
            })
        }
    }
})

async function init() {
    await broker.start()
    broker.repl()
}
init();

call main.begin --a 10 --b 20 --timeout 5000
>> Call 'main.begin' with params: { a: 10, b: 20, timeout: 5000 } with meta: { '$repl': true } with options: {}
Result Got From Remote Services 30 - laptop-r2tggfdl-13828

call main.begin --a 10 --b 20 --timeout 2000
>> Call 'main.begin' with params: { a: 10, b: 20, timeout: 2000 } with meta: { '$repl': true } with options: {}
[2022-05-27T09:43:13.543Z] WARN  laptop-r2tggfdl-13612/BROKER: Request 'remotetimeout.calculate' is timed out. { requestID: '6e3a1abe-432d-41eb-9311-ee9026e207e5', nodeID: 'laptop-r2tggfdl-13828', timeout: 2000 }
[2022-05-27T09:43:13.544Z] WARN  laptop-r2tggfdl-13612/MAIN: The 'main.begin' request is failed. Return fallback response. { requestID: '6e3a1abe-432d-41eb-9311-ee9026e207e5', err: "Request is timed out when call 'remotetimeout.calculate' action on 'laptop-r2tggfdl-13828' node." }
>> Execution time:2s
>> Response:
'From the Cache 0'
............................&&&&&&&&&&&&&&...........................................

.............................&&&&&&&&&&&&&&...................................................
			 Microservices Pattern: Realiability
..............................................................................................

In Microservices, services are talking each other, while talking there are possiblity.

A. Callee Service may slow than expected duration by caller. - Slow calls

B. Callee may throw error , then caller gets exception which will be progataged across the app
   which may stop the entire app.

How to deal / solve the problem of above one ?

   Via Realibility pattern, we can solve the Problem.

Moleculer Provides Fault tolerance , through which we can solve
 

-Timeout

    Service-X  is calling Service-Y

1.You may get Result(succees/errors) "on time".

2.YOu may not get any thing beyond time.

3.Timeout defines deadlines for services


eg:
   Service-X expects result in 500 ms from Service-Y, What if Service-Y not able to give result within that time line , Service-Y will throw TimeoutException.

Now you need to decide how to Handle TimeoutException?

 -throw exception and handle it
 -You can have alternate fallback api to return result to the caller.


Any falut tolerence alogorthim in moleculer can be configured in two places

1.At broker level
const broker = new ServiceBroker({
    requestTimeout: 5 * 1000 // in milliseconds
});

2.At service level

broker.call("posts.find", {}, { timeout: 3000 });


services/remote.main.service.js
const { ServiceBroker } = require('moleculer');

const broker = new ServiceBroker({
    transporter: "TCP",
    requestTimeout: 5 * 1000 // in milliseconds

});
broker.createService({
    name: 'main',
    actions: {

        begin: {
            // Call the 'getCachedResult' method when error occurred
            fallback: "getCachedResult",
            async handler(ctx) {
                const { a, b, timeout } = ctx.params
                let res = await ctx.call('remotetimeout.calculate', { a, b }, {
                    timeout: timeout
                })
                console.log(`Result Got From Remote Services ${res}`)
            }
        }

    },
    methods: {
        getCachedResult() {
            return `From the Cache 0`
        }
    }
})
async function init() {
    await broker.start()
    broker.repl()
}
init();

services/remote.timout.service.js
const { ServiceBroker } = require('moleculer');

const broker = new ServiceBroker({
    transporter: "TCP",
    requestTimeout: 5 * 1000 // in milliseconds
});

broker.createService({
    name: 'remotetimeout',
    actions: {
        async calculate(ctx) {
            const { a, b } = ctx.params
            return new Promise((resolve, reject) => {
                setTimeout(resolve, 3000, `${a + b} - ${broker.nodeID} `)
            })
        }
    }
})

async function init() {
    await broker.start()
    broker.repl()
}
init();
............................................................................................
/////////////////////////////////////////////////////////////////////////////////////////////
				Circuit Breaker
.............................................................................................
CircuitBreaker: 

Automatically fail fast when execution repeatedly fails.

CB is a state machine with three states:
  CLOSED, OPEN, HALF_OPEN

CLOSED : No exception,No Problm in the System.
 if service is working fine, then cb state would be closed.

OPEN:
   if something went wrong, cb opens a cb, tries to trip , never allows further calls

 Service A -----calls -----Service B

 Cb allows serviceA to call Service B if no error/exception.

 cb will never allow ServiceA to call Service B if exception is thrown.

HALF_OPEN:
   if service need to recover from failures to normal state  , cb will go to half_open state 

 from half_open to Open :  still failures are there in the system
 from half_open to closed : Recovered from failures, system is normal


How to implement CB in Moleculer?

1.Broker level : Global cb settings

const broker = new ServiceBroker({
    circuitBreaker: {
        enabled: true,
        threshold: 0.5,
        minRequestCount: 20,
        windowTime: 60, // in seconds
        halfOpenTime: 5 * 1000, // in milliseconds
        check: err => err && err.code >= 500
    }
});

enable: Enable feature
threshold	
   Number	0.5	
   Threshold value. 0.5 means that 50% should be failed for tripping.
minRequestCount	
   Number	20	
  Minimum request count. Below it, CB does not trip (It never goes to open state)

windowTime	
   Number	60	
 Number of seconds for time window.

halfOpenTime	
  Number	10000
 Number of milliseconds to switch from open to half-open state

check	Function	err && err.code >= 500	A function to check failed requests.


2.Service level : Only for particular services

broker.createService({
{
    name: "users",
    actions: {
        create: {
            circuitBreaker: {
                // All CB options can be overwritten from broker options.
                threshold: 0.3,
                windowTime: 30
            },
            handler(ctx) {}
        }
    }
};
})
..............................................................................................


services/main.cb.service.js
const { ServiceBroker } = require('moleculer');

const broker = new ServiceBroker({
    transporter: "TCP",
    circuitBreaker: {
        enabled: true,
        threshold: 0.1,
        minRequestCount: 1,
        windowTime: 60, // in seconds
        halfOpenTime: 5 * 1000, // in milliseconds
        check: err => {
            console.log('check function -Main')
          //  console.log(err)
            return err && err.code >= 500
        }
    }
});
broker.createService({
    name: 'main',
    events: {
        "$circuit-breaker.opened"(opened) {
            console.log("main CB open created -Main service:", opened.nodeID, opened.action);
        },
        "$circuit-breaker.closed"(opened) {
            console.log("main CB closed created -Main service:", opened.nodeID, opened.action);
        },
        "$circuit-breaker.half-opened"(opened) {
            console.log("main CB Half created -Main service:", opened.nodeID, opened.action);
        }

    },
    actions: {
        begin: {
            circuitBreaker: {
                // All CB options can be overwritten from broker options.
                threshold: 0.0,
                windowTime: 30
            },
            fallback: (ctx, err) => `Data From Caching Server ${0}`,
            async handler(ctx) {
                const { a, b, invocationNumber } = ctx.params
                let res = await ctx.call('remotecb.calculate', { a, b, invocationNumber })
                console.log(`Result Got From Remote Services ${res}`)

            }
        }
    }
})

async function init() {
    await broker.start()
    broker.repl()
}
init();

services/remote.cb.service.js
const { ServiceBroker } = require('moleculer');

const broker = new ServiceBroker({
    transporter: "TCP",
    circuitBreaker: {
        enabled: true,
        threshold: 0.1,
        minRequestCount: 1,
        windowTime: 60, // in seconds
        halfOpenTime: 5 * 1000, // in milliseconds
        check: err => {
            console.log('check function -Main')
            console.log(err)
            return err && err.code >= 500
        }
    }
});

broker.createService({
    name: 'remotecb',
    actions: {
        async calculate(ctx) {
            const { a, b, invocationNumber } = ctx.params
            return new Promise((resolve, reject) => {
                if (invocationNumber >= 10) {
                    setTimeout(reject, 100, `Something went wrong`)
                } else {
                    setTimeout(resolve, 100, `${a + b} - ${broker.nodeID} `)
                }
            })
        }
    }
})

async function init() {
    await broker.start()
    broker.repl()
}
init();


Testing:

//failure case
call main.begin --a 10 --b 20 --invocationNumber 9 

//postive case
call main.begin --a 10 --b 20 --invocationNumber 90
.....................................................................................
			Moleculer cli and Moleculer Runner
....................................................................................

Moleculer Runner
 Moleculer Runner is a helper script that helps you run Moleculer projects. With it, you don’t need to create a ServiceBroker instance with options. Instead, you can create a moleculer.config.js file in the root of repo with broker options. Then simply call the moleculer-runner in NPM script, and it will automatically load the configuration file, create the broker and load the services. Alternatively, you can declare your configuration as environment variables.

Moleculer cli
 Provides features
1.create projects
2.mananage project life cycles
3.which embeded moleculer runner.

npm i -g moleculer-cli

Create a project:
moleculer init project my-project
